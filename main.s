;
; File generated by cc65 v 2.19 - Git 394d3b1
;
	.fopt		compiler,"cc65 v 2.19 - Git 394d3b1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_vram_adr
	.import		_vram_put
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.export		_temp0
	.export		_temp1
	.export		_temp2
	.export		_temp3
	.export		_temp4
	.export		_tempShort0
	.export		_global_i
	.export		_global_j
	.export		_frameCount
	.export		_frameCountOverflow
	.export		_rngState
	.export		_prevController
	.export		_controller
	.export		_gameMode
	.export		_cursorX
	.export		_cursorY
	.export		_tempTileX
	.export		_tempTileY
	.export		_numFlags
	.export		_numMinesSetInByte
	.export		_hardSelectionSprite
	.export		_boardIsMine
	.export		_boardIsActivated
	.export		_boardIsFlag
	.export		_fillStackX
	.export		_fillStackY
	.export		_fillStackPos
	.export		_debugTemp0
	.export		_bgPalette
	.export		_sprPalette
	.export		_updateRNGNoController
	.export		_getTileBaseHard
	.export		_setTileBaseHard
	.export		_getTileBaseEasy
	.export		_setTileBaseEasy
	.export		_printNumberDebug
	.export		_printNumber
	.export		_countMinesAroundTileHard
	.export		_generateBoard
	.export		_activateTile
	.export		_activateTileNoCount
	.export		_pushCursorXY
	.export		_popCursorXY
	.export		_hardUpdate
	.export		_update
	.export		_main

.segment	"DATA"

_numMinesSetInByte:
	.word	$0000

.segment	"RODATA"

_bgPalette:
	.byte	$09
	.byte	$1A
	.byte	$0F
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_sprPalette:
	.byte	$09
	.byte	$30
	.byte	$52
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00

.segment	"BSS"

.segment	"ZEROPAGE"
_temp0:
	.res	1,$00
_temp1:
	.res	1,$00
_temp2:
	.res	1,$00
_temp3:
	.res	1,$00
_temp4:
	.res	1,$00
_tempShort0:
	.res	2,$00
_global_i:
	.res	1,$00
_global_j:
	.res	1,$00
_frameCount:
	.res	1,$00
_frameCountOverflow:
	.res	1,$00
_rngState:
	.res	2,$00
_prevController:
	.res	1,$00
_controller:
	.res	1,$00
_gameMode:
	.res	1,$00
_cursorX:
	.res	1,$00
_cursorY:
	.res	1,$00
_tempTileX:
	.res	1,$00
_tempTileY:
	.res	1,$00
_numFlags:
	.res	1,$00
.segment	"BSS"
_hardSelectionSprite:
	.res	4,$00
_boardIsMine:
	.res	104,$00
_boardIsActivated:
	.res	104,$00
_boardIsFlag:
	.res	104,$00
_fillStackX:
	.res	40,$00
_fillStackY:
	.res	40,$00
_fillStackPos:
	.res	1,$00
_debugTemp0:
	.res	1,$00

; ---------------------------------------------------------------
; void __near__ updateController (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateController: near

.segment	"CODE"

;
; prevController = controller;
;
	lda     _controller
	sta     _prevController
;
; controller = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _controller
;
; if((controller & PAD_LEFT) && (controller & PAD_RIGHT)) controller &= ~(0b11u);
;
	and     #$02
	beq     L000D
	lda     _controller
	and     #$01
	beq     L000D
	lda     _controller
	and     #$FC
	sta     _controller
;
; if((controller & PAD_UP) && (controller & PAD_DOWN)) controller &= ~(0b1100u);
;
L000D:	lda     _controller
	and     #$08
	beq     L000F
	lda     _controller
	and     #$04
	bne     L0010
L000F:	rts
L0010:	lda     _controller
	and     #$F3
	sta     _controller
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ updateRNG (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateRNG: near

.segment	"CODE"

;
; __asm__("lda %v", rngState);
;
	lda     _rngState
;
; __asm__("clc");
;
	clc
;
; __asm__("adc %v", controller);
;
	adc     _controller
;
; __asm__("sta %v", rngState);
;
	sta     _rngState
;
; rngState.longState ^= rngState.longState << 7;
;
	ldx     _rngState+1
	jsr     shlax7
	eor     _rngState
	pha
	txa
	eor     _rngState+1
	tax
	pla
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState >> 9;
;
	sta     ptr1
	stx     ptr1+1
	lda     _rngState+1
	lsr     a
	eor     ptr1
	ldx     ptr1+1
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState << 8;
;
	sta     ptr1
	stx     ptr1+1
	ldx     _rngState
	lda     ptr1
	sta     _rngState
	txa
	eor     ptr1+1
	sta     _rngState+1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ updateRNGNoController (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateRNGNoController: near

.segment	"CODE"

;
; rngState.longState ^= rngState.longState << 7;
;
	lda     _rngState
	ldx     _rngState+1
	jsr     shlax7
	eor     _rngState
	pha
	txa
	eor     _rngState+1
	tax
	pla
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState >> 9;
;
	sta     ptr1
	stx     ptr1+1
	lda     _rngState+1
	lsr     a
	eor     ptr1
	ldx     ptr1+1
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState << 8;
;
	sta     ptr1
	stx     ptr1+1
	ldx     _rngState
	lda     ptr1
	sta     _rngState
	txa
	eor     ptr1+1
	sta     _rngState+1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileBaseHard (unsigned char *boardType)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileBaseHard: near

.segment	"CODE"

;
; uchar getTileBaseHard(uchar* boardType) {
;
	jsr     pushax
;
; tempShort0 = ((cursorY << 5) + cursorX); //bit offset
;
	ldx     #$00
	lda     _cursorY
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ldx     tmp1
	clc
	adc     _cursorX
	bcc     L0002
	inx
L0002:	sta     _tempShort0
	stx     _tempShort0+1
;
; return (boardType[tempShort0 >> 3] >> (tempShort0 & 0b111u)) & 0b1u;
;
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     shrax3
	clc
	ldy     #$00
	adc     (sp),y
	sta     ptr1
	txa
	iny
	adc     (sp),y
	sta     ptr1+1
	dey
	lda     (ptr1),y
	sta     ptr1
	lda     _tempShort0
	and     #$07
	tay
	lda     ptr1
L0003:	lsr     a
	dey
	bpl     L0003
	rol     a
	and     #$01
	ldx     #$00
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ setTileBaseHard (unsigned char *boardType, unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileBaseHard: near

.segment	"CODE"

;
; void setTileBaseHard(uchar* boardType, uchar value) {
;
	jsr     pusha
;
; tempShort0 = ((cursorY << 5) + cursorX); //bit offset
;
	ldx     #$00
	lda     _cursorY
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ldx     tmp1
	clc
	adc     _cursorX
	bcc     L0002
	inx
L0002:	sta     _tempShort0
	stx     _tempShort0+1
;
; temp4 = tempShort0 >> 3;
;
	jsr     shrax3
	sta     _temp4
;
; temp3 = tempShort0 & 0b111;
;
	lda     _tempShort0
	and     #$07
	sta     _temp3
;
; boardType[temp4] = (boardType[temp4] & ~(0b1u << temp3)) | (value << temp3);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0003
	inx
L0003:	sta     ptr2
	stx     ptr2+1
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _temp4
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     ptr1
	ldy     _temp3
	lda     #$01
L0006:	asl     a
	dey
	bpl     L0006
	ror     a
	eor     #$FF
	and     ptr1
	sta     sreg
	ldy     #$00
	lda     (sp),y
	sta     ptr1
	ldy     _temp3
	lda     ptr1
L0005:	asl     a
	dey
	bpl     L0005
	ror     a
	ora     sreg
	ldy     #$00
	sta     (ptr2),y
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileBaseEasy (unsigned char *boardType)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileBaseEasy: near

.segment	"CODE"

;
; uchar getTileBaseEasy(uchar* boardType) {
;
	jsr     pushax
;
; tempShort0 = ((cursorY << 4) + cursorX); //bit offset
;
	ldx     #$00
	lda     _cursorY
	jsr     aslax4
	clc
	adc     _cursorX
	bcc     L0002
	inx
L0002:	sta     _tempShort0
	stx     _tempShort0+1
;
; return (boardType[tempShort0 >> 3] >> (tempShort0 & 0b111u)) & 0b1u;
;
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     shrax3
	clc
	ldy     #$00
	adc     (sp),y
	sta     ptr1
	txa
	iny
	adc     (sp),y
	sta     ptr1+1
	dey
	lda     (ptr1),y
	sta     ptr1
	lda     _tempShort0
	and     #$07
	tay
	lda     ptr1
L0003:	lsr     a
	dey
	bpl     L0003
	rol     a
	and     #$01
	ldx     #$00
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ setTileBaseEasy (unsigned char *boardType, unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileBaseEasy: near

.segment	"CODE"

;
; void setTileBaseEasy(uchar* boardType, uchar value) {
;
	jsr     pusha
;
; tempShort0 = ((cursorY << 4) + cursorX); //bit offset
;
	ldx     #$00
	lda     _cursorY
	jsr     aslax4
	clc
	adc     _cursorX
	bcc     L0002
	inx
L0002:	sta     _tempShort0
	stx     _tempShort0+1
;
; temp4 = tempShort0 >> 3;
;
	jsr     shrax3
	sta     _temp4
;
; temp3 = tempShort0 & 0b111;
;
	lda     _tempShort0
	and     #$07
	sta     _temp3
;
; boardType[temp4] = (boardType[temp4] & ~(0b1u << temp3)) | (value << temp3);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0003
	inx
L0003:	sta     ptr2
	stx     ptr2+1
	iny
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _temp4
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     ptr1
	ldy     _temp3
	lda     #$01
L0006:	asl     a
	dey
	bpl     L0006
	ror     a
	eor     #$FF
	and     ptr1
	sta     sreg
	ldy     #$00
	lda     (sp),y
	sta     ptr1
	ldy     _temp3
	lda     ptr1
L0005:	asl     a
	dey
	bpl     L0005
	ror     a
	ora     sreg
	ldy     #$00
	sta     (ptr2),y
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsMineHard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsMineHard: near

.segment	"CODE"

;
; return getTileBaseHard(boardIsMine);
;
	lda     #<(_boardIsMine)
	ldx     #>(_boardIsMine)
	jmp     _getTileBaseHard

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsMineEasy (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsMineEasy: near

.segment	"CODE"

;
; return getTileBaseEasy(boardIsMine);
;
	lda     #<(_boardIsMine)
	ldx     #>(_boardIsMine)
	jmp     _getTileBaseEasy

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsActivatedHard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsActivatedHard: near

.segment	"CODE"

;
; return getTileBaseHard(boardIsActivated);
;
	lda     #<(_boardIsActivated)
	ldx     #>(_boardIsActivated)
	jmp     _getTileBaseHard

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsActivatedHard (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsActivatedHard: near

.segment	"CODE"

;
; inline void setTileIsActivatedHard(uchar value) {
;
	jsr     pusha
;
; setTileBaseHard(boardIsActivated, value);
;
	lda     #<(_boardIsActivated)
	ldx     #>(_boardIsActivated)
	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     _setTileBaseHard
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsActivatedEasy (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsActivatedEasy: near

.segment	"CODE"

;
; return getTileBaseEasy(boardIsActivated);
;
	lda     #<(_boardIsActivated)
	ldx     #>(_boardIsActivated)
	jmp     _getTileBaseEasy

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsActivatedEasy (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsActivatedEasy: near

.segment	"CODE"

;
; inline void setTileIsActivatedEasy(uchar value) {
;
	jsr     pusha
;
; setTileBaseEasy(boardIsActivated, value);
;
	lda     #<(_boardIsActivated)
	ldx     #>(_boardIsActivated)
	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     _setTileBaseEasy
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsFlagHard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsFlagHard: near

.segment	"CODE"

;
; return getTileBaseHard(boardIsFlag);
;
	lda     #<(_boardIsFlag)
	ldx     #>(_boardIsFlag)
	jmp     _getTileBaseHard

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsFlagHard (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsFlagHard: near

.segment	"CODE"

;
; inline void setTileIsFlagHard(uchar value) {
;
	jsr     pusha
;
; setTileBaseHard(boardIsFlag, value);
;
	lda     #<(_boardIsFlag)
	ldx     #>(_boardIsFlag)
	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     _setTileBaseHard
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsFlagEasy (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsFlagEasy: near

.segment	"CODE"

;
; return getTileBaseEasy(boardIsFlag);
;
	lda     #<(_boardIsFlag)
	ldx     #>(_boardIsFlag)
	jmp     _getTileBaseEasy

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsFlagEasy (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsFlagEasy: near

.segment	"CODE"

;
; inline void setTileIsFlagEasy(uchar value) {
;
	jsr     pusha
;
; setTileBaseEasy(boardIsFlag, value);
;
	lda     #<(_boardIsFlag)
	ldx     #>(_boardIsFlag)
	jsr     pushax
	ldy     #$02
	lda     (sp),y
	jsr     _setTileBaseEasy
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ printNumberDebug (unsigned short number, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printNumberDebug: near

.segment	"CODE"

;
; void printNumberDebug(unsigned short number, uchar x, uchar y) {
;
	jsr     pusha
;
; uchar output = 0;
;
	lda     #$00
	jsr     pusha
;
; uchar numberOffset = 0;
;
	jsr     pusha
;
; uchar firstNumber = FALSE;
;
	jsr     pusha
;
; while(number >= 10000) {
;
	jmp     L0004
;
; number -= 10000;
;
L0002:	ldx     #$27
	lda     #$10
	ldy     #$05
	jsr     subeqysp
;
; ++output;
;
	ldy     #$02
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; while(number >= 10000) {
;
L0004:	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$10
	txa
	sbc     #$27
	bcs     L0002
;
; one_vram_buffer(output + NUMBER_TO_TILE, NTADR_A(x, y));
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     #$30
	jsr     pusha
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; firstNumber = TRUE;
;
	lda     #$01
	ldy     #$00
	sta     (sp),y
;
; ++numberOffset;
;
	iny
	clc
	adc     (sp),y
	sta     (sp),y
;
; output = 0;
;
	lda     #$00
	iny
;
; while(number >= 1000) {
;
	jmp     L0017
;
; number -= 1000;
;
L0006:	ldx     #$03
	lda     #$E8
	ldy     #$05
	jsr     subeqysp
;
; ++output;
;
	ldy     #$02
	clc
	lda     #$01
	adc     (sp),y
L0017:	sta     (sp),y
;
; while(number >= 1000) {
;
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$E8
	txa
	sbc     #$03
	bcs     L0006
;
; one_vram_buffer(output + NUMBER_TO_TILE, NTADR_A(x + 1, y));
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     #$30
	jsr     pusha
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     #$01
	bcc     L000A
	inx
L000A:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; firstNumber = TRUE;
;
	lda     #$01
	ldy     #$00
	sta     (sp),y
;
; ++numberOffset;
;
	iny
	clc
	adc     (sp),y
	sta     (sp),y
;
; output = 0;
;
	lda     #$00
	iny
;
; while(number >= 100) {
;
	jmp     L0018
;
; number -= 100;
;
L001A:	lda     #$64
	ldy     #$05
	jsr     subeqysp
;
; ++output;
;
	ldy     #$02
	clc
	lda     #$01
	adc     (sp),y
L0018:	sta     (sp),y
;
; while(number >= 100) {
;
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$64
	txa
	sbc     #$00
	ldx     #$00
	bcs     L001A
;
; one_vram_buffer(output + NUMBER_TO_TILE, NTADR_A(x + 2, y));
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     #$30
	jsr     pusha
	ldy     #$04
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     #$02
	bcc     L000F
	inx
L000F:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; firstNumber = TRUE;
;
	lda     #$01
	ldy     #$00
	sta     (sp),y
;
; ++numberOffset;
;
	iny
	clc
	adc     (sp),y
	sta     (sp),y
;
; output = 0;
;
	lda     #$00
	iny
;
; while(number >= 10) {
;
	jmp     L0019
;
; number -= 10;
;
L001B:	lda     #$0A
	ldy     #$05
	jsr     subeqysp
;
; ++output;
;
	ldy     #$02
	clc
	lda     #$01
	adc     (sp),y
L0019:	sta     (sp),y
;
; while(number >= 10) {
;
	ldy     #$06
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$0A
	txa
	sbc     #$00
	ldx     #$00
	bcs     L001B
;
; one_vram_buffer(output + NUMBER_TO_TILE, NTADR_A(x + 3, y));
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     #$30
	jsr     pusha
	ldy     #$04
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     #$03
	bcc     L0014
	inx
L0014:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; firstNumber = TRUE;
;
	lda     #$01
	ldy     #$00
	sta     (sp),y
;
; ++numberOffset;
;
	iny
	clc
	adc     (sp),y
	sta     (sp),y
;
; output = 0;
;
	lda     #$00
	iny
	sta     (sp),y
;
; one_vram_buffer(number + NUMBER_TO_TILE, NTADR_A(x + 4, y));
;
	ldy     #$05
	lda     (sp),y
	clc
	adc     #$30
	jsr     pusha
	ldy     #$04
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     #$04
	bcc     L0016
	inx
L0016:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; }
;
	jmp     incsp7

.endproc

; ---------------------------------------------------------------
; void __near__ printNumber (unsigned char number, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printNumber: near

.segment	"CODE"

;
; void printNumber(uchar number, uchar x, uchar y) {
;
	jsr     pusha
;
; uchar offset = 0; //also for if the number's begun in bit 7 (save a stack variable)
;
	lda     #$00
	jsr     pusha
;
; temp2 = 0;
;
	sta     _temp2
;
; if(number >= 100) {
;
	ldy     #$03
	lda     (sp),y
	cmp     #$64
	lda     #$00
	bcc     L001C
;
; while(number >= 100) {
;
	jmp     L001A
;
; number -= 100;
;
L0018:	lda     (sp),y
	sec
	sbc     #$64
	sta     (sp),y
;
; ++temp2;
;
	inc     _temp2
;
; while(number >= 100) {
;
L001A:	lda     (sp),y
	cmp     #$64
	bcs     L0018
;
; one_vram_buffer(temp2 + NUMBER_TO_TILE, NTADR_A(x, y));
;
	lda     _temp2
	clc
	adc     #$30
	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; offset += 0b10000001;
;
	ldy     #$00
	clc
	lda     #$81
	adc     (sp),y
	sta     (sp),y
;
; temp2 = 0;
;
	tya
L001C:	sta     _temp2
;
; if(number >= 10) {
;
	ldy     #$03
	lda     (sp),y
	cmp     #$0A
	bcc     L0007
;
; while(number >= 10) {
;
	jmp     L0020
;
; number -= 10;
;
L001E:	lda     (sp),y
	sec
	sbc     #$0A
	sta     (sp),y
;
; ++temp2;
;
	inc     _temp2
;
; while(number >= 10) {
;
L0020:	lda     (sp),y
	cmp     #$0A
	bcs     L001E
;
; one_vram_buffer(temp2 + NUMBER_TO_TILE, NTADR_A(x + (offset & 0b11), y));
;
	lda     _temp2
	clc
	adc     #$30
	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	dey
	lda     (sp),y
	ldx     #$00
	and     #$03
	clc
	ldy     #$03
	adc     (sp),y
	bcc     L0012
	inx
L0012:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; offset++;
;
	ldy     #$00
;
; } else if(offset & 0b10000000) offset++;
;
	jmp     L0028
L0007:	ldy     #$00
	lda     (sp),y
	and     #$80
	beq     L0022
L0028:	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; offset &= ~(0b10000000); //clear the has number begun thingy
;
L0022:	lda     (sp),y
	and     #$7F
	sta     (sp),y
;
; one_vram_buffer(number + NUMBER_TO_TILE, NTADR_A(x + offset, y));
;
	ldy     #$03
	lda     (sp),y
	clc
	adc     #$30
;
; while(offset < 3) {
;
	jmp     L0046
;
; one_vram_buffer(0, NTADR_A(x + offset, y));
;
L0023:	lda     #$00
L0046:	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	dey
	lda     (sp),y
	clc
	ldy     #$03
	adc     (sp),y
	bcc     L0014
	inx
L0014:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++offset;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; while(offset < 3) {
;
	cmp     #$03
	bcc     L0023
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ countMinesAroundTileHard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_countMinesAroundTileHard: near

.segment	"CODE"

;
; temp2 = 0;
;
	lda     #$00
	sta     _temp2
;
; if(cursorX == 0) {
;
	lda     _cursorX
	jne     L0015
;
; if(cursorY == 0) {
;
	lda     _cursorY
	bne     L0013
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorY;
;
	inc     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorX;
;
	dec     _cursorX
;
; } else if(cursorY == (HARD_MAX_Y - 1)) {
;
	jmp     L001D
L0013:	lda     _cursorY
	cmp     #$19
	bne     L0014
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorX;
;
	dec     _cursorX
;
; } else {
;
	jmp     L001D
;
; ++cursorY;
;
L0014:	inc     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorX;
;
	dec     _cursorX
;
; } else if(cursorX == (HARD_MAX_X - 1)) {
;
	jmp     L001D
L0015:	lda     _cursorX
	cmp     #$1F
	bne     L0018
;
; if(cursorY == 0) {
;
	lda     _cursorY
	bne     L0016
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorY;
;
	inc     _cursorY
;
; } else if(cursorY == (HARD_MAX_Y - 1)) {
;
	jmp     L0022
L0016:	lda     _cursorY
	cmp     #$19
	bne     L0017
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; } else {
;
	jmp     L0022
;
; ++cursorY;
;
L0017:	inc     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; } else {
;
	jmp     L0022
;
; if(cursorY == 0) {
;
L0018:	lda     _cursorY
	bne     L0019
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorY;
;
	inc     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; } else if(cursorY == (HARD_MAX_Y - 1)) {
;
	jmp     L001D
L0019:	lda     _cursorY
	cmp     #$19
	bne     L001A
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorY;
;
	inc     _cursorY
;
; } else {
;
	jmp     L001D
;
; ++cursorX;
;
L001A:	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorY;
;
	inc     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorX;
;
	dec     _cursorX
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; --cursorY;
;
	dec     _cursorY
;
; temp2 += getTileIsMineHard();
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
L0022:	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; ++cursorX;
;
	inc     _cursorX
;
; temp2 += getTileIsMineHard();
;
L001D:	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; return temp2;
;
	ldx     #$00
	lda     _temp2
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ generateBoard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_generateBoard: near

.segment	"CODE"

;
; gameMode |= 0b1 << 4; //set board is updating
;
	lda     _gameMode
	ora     #$10
	sta     _gameMode
;
; if((gameMode >> 3) & 0b1) { //is the game in hard mode?
;
	lsr     a
	lsr     a
	lsr     a
	and     #$01
	beq     L0013
;
; temp0 = HARD_NUM_MINES; //250 mines
;
	lda     #$FA
	sta     _temp0
;
; numFlags = HARD_NUM_MINES;
;
	sta     _numFlags
;
; temp1 = HARD_MAX_Y;
;
	lda     #$1A
	sta     _temp1
;
; temp2 = BOARD_MEM_SIZE;
;
	lda     #$68
	sta     _temp2
;
; tempShort0 = HARD_MAX_X * HARD_MAX_Y;
;
	ldx     #$03
	lda     #$40
;
; } else {
;
	jmp     L0017
;
; temp0 = EASY_NUM_MINES; //85 mines
;
L0013:	lda     #$46
	sta     _temp0
;
; numFlags = EASY_NUM_MINES;
;
	sta     _numFlags
;
; temp1 = EASY_MAX_Y;
;
	lda     #$0D
	sta     _temp1
;
; temp2 = EASY_BOARD_USED_MEM_SIZE;
;
	lda     #$1A
	sta     _temp2
;
; tempShort0 = EASY_MAX_X * EASY_MAX_Y;
;
	ldx     #$00
	lda     #$D0
L0017:	sta     _tempShort0
	stx     _tempShort0+1
;
; for(global_i = 0; global_i < temp2; global_i++) {
;
	lda     #$00
	sta     _global_i
L0014:	lda     _global_i
	cmp     _temp2
	bcs     L0016
;
; temp3 = 0; //clear the board
;
	lda     #$00
	sta     _temp3
;
; for(global_j = 0; global_j < 8; global_j++) { //8 bits per byte
;
	sta     _global_j
L0015:	lda     _global_j
	cmp     #$08
	bcs     L0009
;
; updateRNGNoController();
;
	jsr     _updateRNGNoController
;
; temp3 = temp3 << 1;
;
	lda     _temp3
	asl     a
	sta     _temp3
;
; if((rngState.longState % tempShort0) < temp0) { //if randomness says to, add a mine
;
	lda     _rngState
	ldx     _rngState+1
	jsr     pushax
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     tosumodax
	cmp     _temp0
	txa
	sbc     #$00
	bcs     L000C
;
; --temp0; //remove 1 flag from the flags counter
;
	dec     _temp0
;
; temp3 |= 0b1; //add a mine to the lsb of the byte
;
	lda     _temp3
	ora     #$01
	sta     _temp3
;
; ++numMinesSetInByte;
;
	inc     _numMinesSetInByte
	bne     L000C
	inc     _numMinesSetInByte+1
;
; --tempShort0;
;
L000C:	ldx     _tempShort0
	bne     L000E
	dec     _tempShort0+1
L000E:	dex
	stx     _tempShort0
;
; for(global_j = 0; global_j < 8; global_j++) { //8 bits per byte
;
	inc     _global_j
	jmp     L0015
;
; boardIsMine[global_i] = temp3;
;
L0009:	ldy     _global_i
	lda     _temp3
	sta     _boardIsMine,y
;
; boardIsActivated[global_i] = 0;
;
	ldy     _global_i
	lda     #$00
	sta     _boardIsActivated,y
;
; boardIsFlag[global_i] = 0;
;
	ldy     _global_i
	sta     _boardIsFlag,y
;
; for(global_i = 0; global_i < temp2; global_i++) {
;
	inc     _global_i
	jmp     L0014
;
; gameMode &= ~(0b1 << 4); //clear board is updating
;
L0016:	lda     _gameMode
	and     #$EF
	sta     _gameMode
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ activateTile (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_activateTile: near

.segment	"CODE"

;
; setTileIsActivatedHard(TRUE);
;
	lda     #$01
	jsr     _setTileIsActivatedHard
;
; countMinesAroundTileHard();
;
	jsr     _countMinesAroundTileHard
;
; one_vram_buffer(temp2 + NUMBER_TO_NUMBER_TILE, NTADR_A(tempTileX, tempTileY + 3));
;
	lda     _temp2
	clc
	adc     #$10
	jsr     pusha
	ldx     #$00
	lda     _tempTileY
	clc
	adc     #$03
	bcc     L0003
	inx
L0003:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _tempTileX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jmp     _one_vram_buffer

.endproc

; ---------------------------------------------------------------
; void __near__ activateTileNoCount (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_activateTileNoCount: near

.segment	"CODE"

;
; setTileIsActivatedHard(TRUE);
;
	lda     #$01
	jsr     _setTileIsActivatedHard
;
; one_vram_buffer(temp2 + NUMBER_TO_NUMBER_TILE, NTADR_A(cursorX, cursorY + 3));
;
	lda     _temp2
	clc
	adc     #$10
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	clc
	adc     #$03
	bcc     L0003
	inx
L0003:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; if(temp0 >= MAX_FLOOD_FILL_UPDATES) {
;
	lda     _temp0
	cmp     #$20
	bcc     L0004
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; }
;
L0004:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ pushCursorXY (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_pushCursorXY: near

.segment	"CODE"

;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ popCursorXY (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_popCursorXY: near

.segment	"CODE"

;
; cursorX = fillStackX[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	sta     _cursorX
;
; cursorY = fillStackY[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackY,y
	sta     _cursorY
;
; --fillStackPos;
;
	dec     _fillStackPos
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ floodFillZerosHard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_floodFillZerosHard: near

.segment	"CODE"

;
; one_vram_buffer(0x06, PALETTE_MEMORY_BEGIN + 0x0); //second of all, make the screen red (temp, todo remove)
;
	lda     #$06
	jsr     pusha
	ldx     #$3F
	lda     #$00
	jsr     _one_vram_buffer
;
; debugTemp0 = 5;
;
	lda     #$05
	sta     _debugTemp0
;
; fillStackPos = 0;
;
	lda     #$00
	sta     _fillStackPos
;
; fillStackX[0] = tempTileX;
;
	lda     _tempTileX
	sta     _fillStackX
;
; fillStackY[0] = tempTileY;
;
	lda     _tempTileY
	sta     _fillStackY
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; cursorX = fillStackX[fillStackPos];
;
L0002:	ldy     _fillStackPos
	lda     _fillStackX,y
	sta     _cursorX
;
; cursorY = fillStackY[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackY,y
	sta     _cursorY
;
; if(getTileIsActivatedHard()) goto continyue;
;
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; setTileIsActivatedHard(TRUE);
;
	lda     #$01
	jsr     _setTileIsActivatedHard
;
; one_vram_buffer(NUMBER_TO_NUMBER_TILE, NTADR_A(cursorX, cursorY + 3));
;
	lda     #$10
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	clc
	adc     #$03
	bcc     L0009
	inx
L0009:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; if(temp0 >= MAX_FLOOD_FILL_UPDATES) {
;
	lda     _temp0
	cmp     #$20
	bcc     L012B
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; if(cursorX == 0) {
;
L012B:	lda     _cursorX
	jne     L0141
;
; if(cursorY == 0) {
;
	lda     _cursorY
	jne     L0131
;
; ++cursorX;
;
	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L012D
	jsr     _getTileIsActivatedHard
	tax
	bne     L012D
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0011
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L012D
L0011:	jsr     _activateTileNoCount
;
; ++cursorY;
;
L012D:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L012F
	jsr     _getTileIsActivatedHard
	tax
	bne     L012F
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L012F
	jsr     _activateTileNoCount
;
; --cursorX;
;
L012F:	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; } else if(cursorY == (HARD_MAX_Y - 1)) {
;
L0131:	lda     _cursorY
	cmp     #$19
	jne     L0137
;
; ++cursorX;
;
	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0133
	jsr     _getTileIsActivatedHard
	tax
	bne     L0133
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0028
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0133
L0028:	jsr     _activateTileNoCount
;
; --cursorY;
;
L0133:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0135
	jsr     _getTileIsActivatedHard
	tax
	bne     L0135
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0135
	jsr     _activateTileNoCount
;
; --cursorX;
;
L0135:	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; ++cursorY;
;
L0137:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0139
	jsr     _getTileIsActivatedHard
	tax
	bne     L0139
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L003E
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0139
L003E:	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0139:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L013B
	jsr     _getTileIsActivatedHard
	tax
	bne     L013B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L013B
	jsr     _activateTileNoCount
;
; --cursorY;
;
L013B:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L013D
	jsr     _getTileIsActivatedHard
	tax
	bne     L013D
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L004B
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L013D
L004B:	jsr     _activateTileNoCount
;
; --cursorY;
;
L013D:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L013F
	jsr     _getTileIsActivatedHard
	tax
	bne     L013F
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L013F
	jsr     _activateTileNoCount
;
; --cursorX;
;
L013F:	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; } else if(cursorX == (HARD_MAX_X - 1)) {
;
L0141:	lda     _cursorX
	cmp     #$1F
	jne     L0157
;
; if(cursorY == 0) {
;
	lda     _cursorY
	jne     L0147
;
; --cursorX;
;
	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0143
	jsr     _getTileIsActivatedHard
	tax
	bne     L0143
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0063
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0143
L0063:	jsr     _activateTileNoCount
;
; ++cursorY;
;
L0143:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0145
	jsr     _getTileIsActivatedHard
	tax
	bne     L0145
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0145
	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0145:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; } else if(cursorY == (HARD_MAX_Y - 1)) {
;
L0147:	lda     _cursorY
	cmp     #$19
	jne     L014D
;
; --cursorX;
;
	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0149
	jsr     _getTileIsActivatedHard
	tax
	bne     L0149
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L007A
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0149
L007A:	jsr     _activateTileNoCount
;
; --cursorY;
;
L0149:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L014B
	jsr     _getTileIsActivatedHard
	tax
	bne     L014B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L014B
	jsr     _activateTileNoCount
;
; ++cursorX;
;
L014B:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; ++cursorY;
;
L014D:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L014F
	jsr     _getTileIsActivatedHard
	tax
	bne     L014F
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0090
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L014F
L0090:	jsr     _activateTileNoCount
;
; --cursorX;
;
L014F:	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0151
	jsr     _getTileIsActivatedHard
	tax
	bne     L0151
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0151
	jsr     _activateTileNoCount
;
; --cursorY;
;
L0151:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0153
	jsr     _getTileIsActivatedHard
	tax
	bne     L0153
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L009D
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0153
L009D:	jsr     _activateTileNoCount
;
; --cursorY;
;
L0153:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0155
	jsr     _getTileIsActivatedHard
	tax
	bne     L0155
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0155
	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0155:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; if(cursorY == 0) {
;
L0157:	lda     _cursorY
	jne     L0161
;
; --cursorX;
;
	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0159
	jsr     _getTileIsActivatedHard
	tax
	bne     L0159
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L00B4
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0159
L00B4:	jsr     _activateTileNoCount
;
; ++cursorY;
;
L0159:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L015B
	jsr     _getTileIsActivatedHard
	tax
	bne     L015B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L015B
	jsr     _activateTileNoCount
;
; ++cursorX;
;
L015B:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L015D
	jsr     _getTileIsActivatedHard
	tax
	bne     L015D
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L00C1
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L015D
L00C1:	jsr     _activateTileNoCount
;
; ++cursorX;
;
L015D:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L015F
	jsr     _getTileIsActivatedHard
	tax
	bne     L015F
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L015F
	jsr     _activateTileNoCount
;
; --cursorY;
;
L015F:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; } else if(cursorY == (HARD_MAX_Y - 1)) {
;
L0161:	lda     _cursorY
	cmp     #$19
	jne     L016B
;
; --cursorX;
;
	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0163
	jsr     _getTileIsActivatedHard
	tax
	bne     L0163
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L00D8
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0163
L00D8:	jsr     _activateTileNoCount
;
; --cursorY;
;
L0163:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0165
	jsr     _getTileIsActivatedHard
	tax
	bne     L0165
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0165
	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0165:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0167
	jsr     _getTileIsActivatedHard
	tax
	bne     L0167
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L00E5
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0167
L00E5:	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0167:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0169
	jsr     _getTileIsActivatedHard
	tax
	bne     L0169
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0169
	jsr     _activateTileNoCount
;
; ++cursorY;
;
L0169:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	jne     L017B
	jsr     _getTileIsActivatedHard
	tax
	jne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	jne     L017C
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L017B
;
; ++cursorX;
;
L016B:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L016D
	jsr     _getTileIsActivatedHard
	tax
	bne     L016D
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L00FB
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L016D
L00FB:	jsr     _activateTileNoCount
;
; ++cursorY;
;
L016D:	inc     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L016F
	jsr     _getTileIsActivatedHard
	tax
	bne     L016F
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L016F
	jsr     _activateTileNoCount
;
; --cursorX;
;
L016F:	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0171
	jsr     _getTileIsActivatedHard
	tax
	bne     L0171
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0108
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0171
L0108:	jsr     _activateTileNoCount
;
; --cursorX;
;
L0171:	dec     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0173
	jsr     _getTileIsActivatedHard
	tax
	bne     L0173
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0173
	jsr     _activateTileNoCount
;
; --cursorY;
;
L0173:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0175
	jsr     _getTileIsActivatedHard
	tax
	bne     L0175
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0115
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0175
L0115:	jsr     _activateTileNoCount
;
; --cursorY;
;
L0175:	dec     _cursorY
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0177
	jsr     _getTileIsActivatedHard
	tax
	bne     L0177
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L0177
	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0177:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L0179
	jsr     _getTileIsActivatedHard
	tax
	bne     L0179
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0122
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; } else activateTileNoCount();
;
	jmp     L0179
L0122:	jsr     _activateTileNoCount
;
; ++cursorX;
;
L0179:	inc     _cursorX
;
; if(!getTileIsMineHard() && !getTileIsActivatedHard()) {
;
	jsr     _getTileIsMineHard
	tax
	bne     L017B
	jsr     _getTileIsActivatedHard
	tax
	bne     L017B
;
; pushCursorXY();                     temp2 = countMinesAroundTileHard();                     popCursorXY();
;
	jsr     _pushCursorXY
	jsr     _countMinesAroundTileHard
	sta     _temp2
	jsr     _popCursorXY
;
; if(temp2 != 0) activateTileNoCount();
;
	lda     _temp2
	beq     L017B
L017C:	jsr     _activateTileNoCount
;
; --fillStackPos;
;
L017B:	dec     _fillStackPos
;
; } while(fillStackPos > 0);
;
	lda     _fillStackPos
	jne     L0002
;
; temp0 = 0;
;
	sta     _temp0
;
; }
;
	rts

.segment	"RODATA"

M0001:
	.word	$0000

.endproc

; ---------------------------------------------------------------
; void __near__ hardUpdate (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_hardUpdate: near

.segment	"CODE"

;
; if(debugTemp0) {
;
	lda     _debugTemp0
	beq     L0030
;
; --debugTemp0;
;
	dec     _debugTemp0
;
; if(!debugTemp0) one_vram_buffer(0x09, PALETTE_MEMORY_BEGIN + 0x0); //make the screen normal again
;
	bne     L0003
	lda     #$09
	jsr     pusha
	ldx     #$3F
	lda     #$00
	jsr     _one_vram_buffer
;
; __asm__("lda #$00");
;
L0003:	lda     #$00
;
; __asm__("sta %v", temp1);
;
L0030:	sta     _temp1
;
; if(BUTTON_DOWN(PAD_RIGHT)) {
;
	lda     _controller
	and     #$01
	beq     L0034
	lda     _prevController
	and     #$01
	bne     L0034
;
; __asm__("ldx %v", cursorX);
;
	ldx     _cursorX
;
; __asm__("inx");
;
	inx
;
; __asm__("cpx #%b", HARD_MAX_X);
;
	cpx     #$20
;
; __asm__("bne @padRightSkip");
;
	bne     @padRightSkip
;
; __asm__("ldx #$00");
;
	tax
;
; __asm__("stx %v", cursorX);
;
@padRightSkip:
	stx     _cursorX
;
; __asm__("lda #%b", TRUE);
;
	lda     #$01
;
; __asm__("sta %v", temp1);
;
	sta     _temp1
;
; if(BUTTON_DOWN(PAD_LEFT)) {
;
L0034:	lda     _controller
	and     #$02
	beq     L0038
	lda     _prevController
	and     #$02
	bne     L0038
;
; __asm__("ldx %v", cursorX);
;
	ldx     _cursorX
;
; __asm__("dex");
;
	dex
;
; __asm__("bpl @padLeftSkip");
;
	bpl     @padLeftSkip
;
; __asm__("ldx #%b", HARD_MAX_X - 1);
;
	ldx     #$1F
;
; __asm__("stx %v", cursorX);
;
@padLeftSkip:
	stx     _cursorX
;
; __asm__("lda #%b", TRUE);
;
	lda     #$01
;
; __asm__("sta %v", temp1);
;
	sta     _temp1
;
; if(BUTTON_DOWN(PAD_DOWN)) {
;
L0038:	lda     _controller
	and     #$04
	beq     L003C
	lda     _prevController
	and     #$04
	bne     L003C
;
; __asm__("ldx %v", cursorY);
;
	ldx     _cursorY
;
; __asm__("inx");
;
	inx
;
; __asm__("cpx #%b", HARD_MAX_Y);
;
	cpx     #$1A
;
; __asm__("bne @padDownSkip");
;
	bne     @padDownSkip
;
; __asm__("ldx #00");
;
	tax
;
; __asm__("stx %v", cursorY);
;
@padDownSkip:
	stx     _cursorY
;
; __asm__("lda #%b", TRUE);
;
	lda     #$01
;
; __asm__("sta %v", temp1);
;
	sta     _temp1
;
; if(BUTTON_DOWN(PAD_UP)) {
;
L003C:	lda     _controller
	and     #$08
	beq     L0010
	lda     _prevController
	and     #$08
	bne     L0010
;
; __asm__("ldx %v", cursorY);
;
	ldx     _cursorY
;
; __asm__("dex");
;
	dex
;
; __asm__("bpl @padUpSkip");
;
	bpl     @padUpSkip
;
; __asm__("ldx #%b", HARD_MAX_Y - 1);
;
	ldx     #$19
;
; __asm__("stx %v", cursorY);
;
@padUpSkip:
	stx     _cursorY
;
; __asm__("lda #%b", TRUE);
;
	lda     #$01
;
; __asm__("sta %v", temp1);
;
	sta     _temp1
;
; if(temp1) {
;
L0010:	lda     _temp1
	beq     L0014
;
; printNumber(cursorX, 1, 1);
;
	jsr     decsp2
	lda     _cursorX
	ldy     #$01
	sta     (sp),y
	tya
	dey
	sta     (sp),y
	jsr     _printNumber
;
; printNumber(cursorY, 4, 1);
;
	jsr     decsp2
	lda     _cursorY
	ldy     #$01
	sta     (sp),y
	lda     #$04
	dey
	sta     (sp),y
	lda     #$01
	jsr     _printNumber
;
; hardSelectionSprite.xPos = cursorX << 3; //x8 to align w/ tiles
;
L0014:	lda     _cursorX
	asl     a
	asl     a
	asl     a
	sta     _hardSelectionSprite+3
;
; hardSelectionSprite.yPos = (cursorY << 3) + 23; //1 less to be 1 higher (properly aligned)
;
	lda     _cursorY
	asl     a
	asl     a
	asl     a
	clc
	adc     #$17
	sta     _hardSelectionSprite
;
; if((frameCount & 0b11111) == 0) {
;
	lda     _frameCount
	and     #$1F
	bne     L0041
;
; if((frameCount & 0b111111) == 0) one_vram_buffer(WHITE, PALETTE_MEMORY_BEGIN + 0x11);
;
	lda     _frameCount
	and     #$3F
	bne     L0040
	lda     #$30
;
; else one_vram_buffer(0x38, PALETTE_MEMORY_BEGIN + 0x11);
;
	jmp     L0050
L0040:	lda     #$38
L0050:	jsr     pusha
	ldx     #$3F
	lda     #$11
	jsr     _one_vram_buffer
;
; if(BUTTON_DOWN(PAD_B) && !getTileIsActivatedHard()) {
;
L0041:	lda     _controller
	and     #$40
	jeq     L0046
	lda     _prevController
	and     #$40
	jne     L0046
	jsr     _getTileIsActivatedHard
	tax
	jne     L0046
;
; if(getTileIsFlagHard()) {
;
	jsr     _getTileIsFlagHard
	tax
	beq     L0045
;
; ++numFlags;
;
	inc     _numFlags
;
; setTileIsFlagHard(FALSE);
;
	lda     #$00
	jsr     _setTileIsFlagHard
;
; one_vram_buffer(0x8 + (((cursorX & 0b1) ^ (cursorY & 0b1)) << 1), NTADR_A(cursorX, cursorY + 3));
;
	lda     _cursorX
	and     #$01
	jsr     pusha0
	lda     _cursorY
	and     #$01
	jsr     tosxora0
	asl     a
	clc
	adc     #$08
;
; } else if(numFlags > 0) {
;
	jmp     L0060
L0045:	lda     _numFlags
	beq     L0023
;
; --numFlags;
;
	dec     _numFlags
;
; setTileIsFlagHard(TRUE);
;
	lda     #$01
	jsr     _setTileIsFlagHard
;
; one_vram_buffer(0x9 + (((cursorX & 0b1) ^ (cursorY & 0b1)) << 1), NTADR_A(cursorX, cursorY + 3));
;
	lda     _cursorX
	and     #$01
	jsr     pusha0
	lda     _cursorY
	and     #$01
	jsr     tosxora0
	asl     a
	clc
	adc     #$09
L0060:	jsr     pusha
	ldx     #$00
	lda     _cursorY
	clc
	adc     #$03
	bcc     L0025
	inx
L0025:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; printNumber(numFlags, 7, 1);
;
L0023:	jsr     decsp2
	lda     _numFlags
	ldy     #$01
	sta     (sp),y
	lda     #$07
	dey
	sta     (sp),y
	lda     #$01
	jsr     _printNumber
;
; tempTileX = cursorX;
;
L0046:	lda     _cursorX
	sta     _tempTileX
;
; tempTileY = cursorY;
;
	lda     _cursorY
	sta     _tempTileY
;
; if(BUTTON_DOWN(PAD_A) && !getTileIsFlagHard() && !getTileIsActivatedHard()) {
;
	lda     _controller
	and     #$80
	beq     L0026
	lda     _prevController
	and     #$80
	bne     L0026
	jsr     _getTileIsFlagHard
	tax
	bne     L0026
	jsr     _getTileIsActivatedHard
	tax
	bne     L0026
;
; if(getTileIsMineHard()) {
;
	jsr     _getTileIsMineHard
	tax
	beq     L002A
;
; one_vram_buffer(0x06, PALETTE_MEMORY_BEGIN + 0x0); //second of all, make the screen red (temp, todo remove)
;
	lda     #$06
	jsr     pusha
	ldx     #$3F
	lda     #$00
	jsr     _one_vram_buffer
;
; debugTemp0 = 5;
;
	lda     #$05
	sta     _debugTemp0
;
; } else {
;
	jmp     L004B
;
; countMinesAroundTileHard();
;
L002A:	jsr     _countMinesAroundTileHard
;
; if(temp2 == 0) floodFillZerosHard(); //enjoy
;
	lda     _temp2
	bne     L004A
	jsr     _floodFillZerosHard
;
; else {
;
	jmp     L004B
;
; cursorX = tempTileX;
;
L004A:	lda     _tempTileX
	sta     _cursorX
;
; cursorY = tempTileY;
;
	lda     _tempTileY
	sta     _cursorY
;
; activateTileNoCount();
;
	jsr     _activateTileNoCount
;
; cursorX = tempTileX;
;
L004B:	lda     _tempTileX
	sta     _cursorX
;
; cursorY = tempTileY;
;
	lda     _tempTileY
	sta     _cursorY
;
; oam_clear();
;
L0026:	jsr     _oam_clear
;
; oam_spr(hardSelectionSprite.xPos, hardSelectionSprite.yPos, hardSelectionSprite.tile, hardSelectionSprite.attributes);
;
	jsr     decsp3
	lda     _hardSelectionSprite+3
	ldy     #$02
	sta     (sp),y
	lda     _hardSelectionSprite
	dey
	sta     (sp),y
	lda     _hardSelectionSprite+1
	dey
	sta     (sp),y
	lda     _hardSelectionSprite+2
	jmp     _oam_spr

.endproc

; ---------------------------------------------------------------
; void __near__ initState (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_initState: near

.segment	"CODE"

;
; prevController = 0;
;
	lda     #$00
	sta     _prevController
;
; controller = 0;
;
	sta     _controller
;
; rngState.byte1 = 0xC2;
;
	lda     #$C2
	sta     _rngState
;
; rngState.byte2 = 0xE3;
;
	lda     #$E3
	sta     _rngState+1
;
; frameCount = 0;
;
	lda     #$00
	sta     _frameCount
;
; hardSelectionSprite.tile = 0x00;
;
	sta     _hardSelectionSprite+1
;
; hardSelectionSprite.attributes = 0b00000000;
;
	sta     _hardSelectionSprite+2
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update: near

.segment	"CODE"

;
; updateController();
;
	jsr     _updateController
;
; updateRNG();
;
	jsr     _updateRNG
;
; hardUpdate();
;
	jsr     _hardUpdate
;
; __asm__("inc %v", frameCount);
;
	inc     _frameCount
;
; __asm__("bne @frameCountNoOverflow"); //aka zero flag is set aka overflow happened
;
	bne     @frameCountNoOverflow
;
; frameCountOverflow = TRUE;
;
	lda     #$01
;
; return;
;
	jmp     L0002
;
; frameCountOverflow = FALSE;
;
@frameCountNoOverflow:
	lda     #$00
L0002:	sta     _frameCountOverflow
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; initState();
;
	jsr     _initState
;
; gameMode |= (0b1 << 3);
;
	lda     _gameMode
	ora     #$08
	sta     _gameMode
;
; ppu_off(); //screen off
;
	jsr     _ppu_off
;
; generateBoard();
;
	jsr     _generateBoard
;
; pal_bg(bgPalette);
;
	lda     #<(_bgPalette)
	ldx     #>(_bgPalette)
	jsr     _pal_bg
;
; pal_spr(sprPalette);
;
	lda     #<(_sprPalette)
	ldx     #>(_sprPalette)
	jsr     _pal_spr
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; for(global_i = 0; global_i < HARD_MAX_X; ++global_i) {
;
	lda     #$00
	sta     _global_i
L000F:	lda     _global_i
	cmp     #$20
	bcs     L0003
;
; for(global_j = 0; global_j < HARD_MAX_Y; ++global_j) {
;
	lda     #$00
	sta     _global_j
L0010:	lda     _global_j
	cmp     #$1A
	bcs     L0011
;
; temp2 = 0x8 + (((global_i & 0b1) ^ (global_j & 0b1)) << 1); //tile num, alternates as a checkerboard
;
	lda     _global_i
	and     #$01
	jsr     pusha0
	lda     _global_j
	and     #$01
	jsr     tosxora0
	asl     a
	clc
	adc     #$08
	sta     _temp2
;
; cursorX = global_i;
;
	lda     _global_i
	sta     _cursorX
;
; cursorY = global_j;
;
	lda     _global_j
	sta     _cursorY
;
; temp2 += getTileIsMineHard(); //1 = mine, 0 = no mine
;
	jsr     _getTileIsMineHard
	clc
	adc     _temp2
	sta     _temp2
;
; vram_adr(NTADR_A(global_i, global_j + 3));
;
	ldx     #$00
	lda     _global_j
	clc
	adc     #$03
	bcc     L000B
	inx
L000B:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _global_i
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(temp2);
;
	lda     _temp2
	jsr     _vram_put
;
; for(global_j = 0; global_j < HARD_MAX_Y; ++global_j) {
;
	inc     _global_j
	jmp     L0010
;
; for(global_i = 0; global_i < HARD_MAX_X; ++global_i) {
;
L0011:	inc     _global_i
	jmp     L000F
;
; ppu_on_all();
;
L0003:	jsr     _ppu_on_all
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; cursorX = 0;
;
	lda     #$00
	sta     _cursorX
;
; cursorY = 0;
;
	sta     _cursorY
;
; printNumber(cursorX, 1, 1);
;
	jsr     decsp2
	lda     _cursorX
	ldy     #$01
	sta     (sp),y
	tya
	dey
	sta     (sp),y
	jsr     _printNumber
;
; printNumber(cursorY, 4, 1);
;
	jsr     decsp2
	lda     _cursorY
	ldy     #$01
	sta     (sp),y
	lda     #$04
	dey
	sta     (sp),y
	lda     #$01
	jsr     _printNumber
;
; printNumber(numFlags, 7, 1);
;
	jsr     decsp2
	lda     _numFlags
	ldy     #$01
	sta     (sp),y
	lda     #$07
	dey
	sta     (sp),y
	lda     #$01
	jsr     _printNumber
;
; ppu_wait_nmi();
;
L000C:	jsr     _ppu_wait_nmi
;
; update();
;
	jsr     _update
;
; while(TRUE) {
;
	jmp     L000C

.endproc

