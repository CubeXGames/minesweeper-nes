;
; File generated by cc65 v 2.19 - Git 394d3b1
;
	.fopt		compiler,"cc65 v 2.19 - Git 394d3b1"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_bright
	.import		_pal_bg_bright
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_oam_meta_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_vram_adr
	.import		_vram_put
	.import		_vram_fill
	.import		_vram_unrle
	.import		_delay
	.import		_set_vram_buffer
	.import		_one_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_multi_vram_buffer_horz_fill
	.import		_clear_vram_buffer
	.import		_pal_fade_to
	.import		_color_emphasis
	.export		_titleScreenNametable
	.export		_selectScreenNametable
	.export		_gameEndScreenNametable
	.export		_countMinesAroundTile
	.export		_activateTileNoCount
	.export		_temp0
	.export		_temp1
	.export		_temp2
	.export		_temp3
	.export		_temp4
	.export		_tempShort0
	.export		_global_i
	.export		_global_j
	.export		_ushort_i
	.export		_frameCount
	.export		_secondsFrameCount
	.export		_rngState
	.export		_prevController
	.export		_controller
	.export		_gameMode
	.export		_cursorX
	.export		_cursorY
	.export		_tempTileX
	.export		_tempTileY
	.export		_numFlags
	.export		_numTilesLeft
	.export		_timePlayedSeconds
	.export		_timePlayedMinutes
	.export		_boardWidth
	.export		_boardHeight
	.export		_maxMines
	.export		_minMines
	.export		_isCustomSeed
	.export		_customSeed
	.export		_checkAdjacentTilesFunction
	.export		_selectionSprite
	.export		_boardIsMine
	.export		_boardIsActivated
	.export		_boardIsFlag
	.export		_fillStackX
	.export		_fillStackY
	.export		_fillStackPos
	.export		_tileBitShiftOffset
	.export		_attributeTableMirror
	.export		_selectionArrow
	.export		_selectionArrowIndex
	.export		_selectionArrowNumIndices
	.export		_selectionArrowPositionsX
	.export		_selectionArrowPositionsY
	.export		_selectionArrowShouldUseArrow
	.export		_isNumberArrowUp
	.export		_selectionArrowTargetPosX
	.export		_selectionArrowTargetPosY
	.export		_numMines
	.export		_boardSeed
	.export		_boardType
	.export		_debugTemp0
	.export		_gameBgPalette
	.export		_titleScreenBgPalette
	.export		_gameEndPalette
	.export		_sprPalette
	.export		_easySelectorMetasprite
	.export		_pausedText
	.export		_leaveText
	.export		_newGameText
	.export		_backText
	.export		_pressStartText
	.export		_youWonText
	.export		_gameOverText
	.export		_gamePauseMenuPositionsX
	.export		_gamePauseMenuPositionsY
	.export		_gamePauseMenuShouldUseArrow
	.export		_gameSelectPositionsX
	.export		_gameSelectPositionsY
	.export		_gameSelectShouldUseArrow
	.export		_showTitleScreen
	.export		_updateRNGNoController
	.export		_getTileBase
	.export		_setTileBase
	.export		_printNumber
	.export		_printHexNumber
	.export		_printTime
	.export		_printString
	.export		_printTile
	.export		_clearScreen
	.export		_checkAdjacentTiles
	.export		_pushCursorXY
	.export		_popCursorXY
	.export		__countMines
	.export		__checkFloodFillPos
	.export		__checkPos2
	.export		_changeAttributeTable
	.export		_activateTileBase
	.export		_activateTile
	.export		_generateBoard
	.export		_displayBoard
	.export		_updateSelectionArrow
	.export		_showSelectScreen
	.export		_loadSelectScreen
	.export		_updateTitleScreen
	.export		_updateGameSelection
	.export		_update
	.export		_main

.segment	"DATA"

_gameSelectShouldUseArrow:
	.byte	$01
	.byte	$01
	.byte	$00
	.byte	$01
	.byte	$01
	.byte	$01

.segment	"RODATA"

_titleScreenNametable:
	.byte	$02
	.byte	$09
	.byte	$02
	.byte	$46
	.byte	$10
	.byte	$20
	.byte	$11
	.byte	$20
	.byte	$12
	.byte	$09
	.byte	$22
	.byte	$09
	.byte	$22
	.byte	$09
	.byte	$09
	.byte	$22
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$02
	.byte	$0E
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$23
	.byte	$11
	.byte	$29
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$28
	.byte	$19
	.byte	$16
	.byte	$09
	.byte	$18
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$02
	.byte	$0F
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$11
	.byte	$24
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$14
	.byte	$20
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$02
	.byte	$28
	.byte	$10
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$22
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$22
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$12
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$20
	.byte	$12
	.byte	$09
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$09
	.byte	$14
	.byte	$20
	.byte	$12
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$22
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$18
	.byte	$25
	.byte	$09
	.byte	$09
	.byte	$18
	.byte	$25
	.byte	$09
	.byte	$09
	.byte	$18
	.byte	$20
	.byte	$15
	.byte	$09
	.byte	$18
	.byte	$25
	.byte	$09
	.byte	$09
	.byte	$18
	.byte	$20
	.byte	$11
	.byte	$15
	.byte	$09
	.byte	$02
	.byte	$03
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$13
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$26
	.byte	$20
	.byte	$15
	.byte	$09
	.byte	$14
	.byte	$20
	.byte	$17
	.byte	$20
	.byte	$15
	.byte	$09
	.byte	$14
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$14
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$02
	.byte	$02
	.byte	$14
	.byte	$20
	.byte	$25
	.byte	$09
	.byte	$24
	.byte	$09
	.byte	$1A
	.byte	$1B
	.byte	$09
	.byte	$02
	.byte	$8A
	.byte	$50
	.byte	$52
	.byte	$45
	.byte	$53
	.byte	$53
	.byte	$09
	.byte	$53
	.byte	$54
	.byte	$41
	.byte	$52
	.byte	$54
	.byte	$09
	.byte	$02
	.byte	$FE
	.byte	$09
	.byte	$02
	.byte	$4C
	.byte	$5B
	.byte	$09
	.byte	$43
	.byte	$55
	.byte	$42
	.byte	$45
	.byte	$58
	.byte	$09
	.byte	$32
	.byte	$30
	.byte	$32
	.byte	$35
	.byte	$09
	.byte	$02
	.byte	$32
	.byte	$AA
	.byte	$02
	.byte	$0F
	.byte	$00
	.byte	$02
	.byte	$11
	.byte	$04
	.byte	$05
	.byte	$05
	.byte	$01
	.byte	$00
	.byte	$02
	.byte	$11
	.byte	$05
	.byte	$02
	.byte	$02
	.byte	$01
	.byte	$00
	.byte	$02
	.byte	$03
	.byte	$02
	.byte	$00
_selectScreenNametable:
	.byte	$00
	.byte	$09
	.byte	$00
	.byte	$41
	.byte	$4E
	.byte	$45
	.byte	$57
	.byte	$09
	.byte	$47
	.byte	$41
	.byte	$4D
	.byte	$45
	.byte	$09
	.byte	$00
	.byte	$77
	.byte	$47
	.byte	$41
	.byte	$4D
	.byte	$45
	.byte	$09
	.byte	$44
	.byte	$49
	.byte	$46
	.byte	$46
	.byte	$49
	.byte	$43
	.byte	$55
	.byte	$4C
	.byte	$54
	.byte	$59
	.byte	$09
	.byte	$00
	.byte	$16
	.byte	$0D
	.byte	$00
	.byte	$04
	.byte	$09
	.byte	$00
	.byte	$15
	.byte	$5D
	.byte	$45
	.byte	$41
	.byte	$53
	.byte	$59
	.byte	$5E
	.byte	$0D
	.byte	$09
	.byte	$48
	.byte	$41
	.byte	$52
	.byte	$44
	.byte	$09
	.byte	$00
	.byte	$04
	.byte	$61
	.byte	$00
	.byte	$04
	.byte	$09
	.byte	$00
	.byte	$28
	.byte	$4E
	.byte	$55
	.byte	$4D
	.byte	$42
	.byte	$45
	.byte	$52
	.byte	$09
	.byte	$4F
	.byte	$46
	.byte	$09
	.byte	$4D
	.byte	$49
	.byte	$4E
	.byte	$45
	.byte	$53
	.byte	$09
	.byte	$00
	.byte	$31
	.byte	$0E
	.byte	$0F
	.byte	$09
	.byte	$00
	.byte	$3C
	.byte	$43
	.byte	$55
	.byte	$53
	.byte	$54
	.byte	$4F
	.byte	$4D
	.byte	$09
	.byte	$53
	.byte	$45
	.byte	$45
	.byte	$44
	.byte	$5C
	.byte	$09
	.byte	$00
	.byte	$35
	.byte	$59
	.byte	$45
	.byte	$53
	.byte	$09
	.byte	$09
	.byte	$5D
	.byte	$4E
	.byte	$4F
	.byte	$5E
	.byte	$09
	.byte	$00
	.byte	$35
	.byte	$53
	.byte	$54
	.byte	$41
	.byte	$52
	.byte	$54
	.byte	$09
	.byte	$47
	.byte	$41
	.byte	$4D
	.byte	$45
	.byte	$09
	.byte	$00
	.byte	$FE
	.byte	$09
	.byte	$00
	.byte	$73
	.byte	$FF
	.byte	$00
	.byte	$37
	.byte	$0F
	.byte	$00
	.byte	$07
	.byte	$00
	.byte	$00
_gameEndScreenNametable:
	.byte	$01
	.byte	$09
	.byte	$01
	.byte	$FE
	.byte	$09
	.byte	$01
	.byte	$09
	.byte	$10
	.byte	$20
	.byte	$01
	.byte	$0B
	.byte	$29
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$0D
	.byte	$01
	.byte	$09
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$54
	.byte	$49
	.byte	$4D
	.byte	$45
	.byte	$2D
	.byte	$09
	.byte	$01
	.byte	$05
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$53
	.byte	$45
	.byte	$45
	.byte	$44
	.byte	$2D
	.byte	$09
	.byte	$01
	.byte	$05
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$09
	.byte	$4E
	.byte	$45
	.byte	$57
	.byte	$09
	.byte	$47
	.byte	$41
	.byte	$4D
	.byte	$45
	.byte	$09
	.byte	$09
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$09
	.byte	$45
	.byte	$58
	.byte	$49
	.byte	$54
	.byte	$09
	.byte	$01
	.byte	$05
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$0B
	.byte	$13
	.byte	$09
	.byte	$01
	.byte	$11
	.byte	$28
	.byte	$20
	.byte	$01
	.byte	$0B
	.byte	$15
	.byte	$09
	.byte	$01
	.byte	$C8
	.byte	$00
	.byte	$01
	.byte	$3F
	.byte	$01
	.byte	$00
_gameBgPalette:
	.byte	$09
	.byte	$1A
	.byte	$0F
	.byte	$30
	.byte	$09
	.byte	$08
	.byte	$19
	.byte	$30
	.byte	$09
	.byte	$08
	.byte	$19
	.byte	$21
	.byte	$09
	.byte	$0F
	.byte	$0A
	.byte	$30
_titleScreenBgPalette:
	.byte	$1B
	.byte	$0F
	.byte	$0F
	.byte	$28
	.byte	$1B
	.byte	$11
	.byte	$22
	.byte	$30
	.byte	$1B
	.byte	$0F
	.byte	$0F
	.byte	$21
	.byte	$1B
	.byte	$30
	.byte	$0F
	.byte	$30
_gameEndPalette:
	.byte	$09
	.byte	$0F
	.byte	$0F
	.byte	$30
	.byte	$09
	.byte	$21
	.byte	$05
	.byte	$30
	.byte	$09
	.byte	$22
	.byte	$27
	.byte	$13
	.byte	$09
	.byte	$08
	.byte	$19
	.byte	$30
_sprPalette:
	.byte	$09
	.byte	$38
	.byte	$27
	.byte	$30
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_easySelectorMetasprite:
	.byte	$00
	.byte	$00
	.byte	$01
	.byte	$00
	.byte	$08
	.byte	$00
	.byte	$01
	.byte	$40
	.byte	$00
	.byte	$08
	.byte	$01
	.byte	$80
	.byte	$08
	.byte	$08
	.byte	$01
	.byte	$C0
	.byte	$80
_pausedText:
	.byte	$50,$41,$55,$53,$45,$44
_leaveText:
	.byte	$45,$58,$49,$54
_newGameText:
	.byte	$4E,$45,$57,$09,$47,$41,$4D,$45
_backText:
	.byte	$42,$41,$43,$4B,$09,$54,$4F,$09,$47,$41,$4D,$45
_pressStartText:
	.byte	$50,$52,$45,$53,$53,$09,$53,$54,$41,$52,$54
_youWonText:
	.byte	$59,$4F,$55,$09,$57,$4F,$4E,$21
_gameOverText:
	.byte	$47,$41,$4D,$45,$09,$4F,$56,$45,$52,$21
_gamePauseMenuPositionsX:
	.byte	$60
	.byte	$60
	.byte	$D0
_gamePauseMenuPositionsY:
	.byte	$0E
	.byte	$16
	.byte	$0E
_gamePauseMenuShouldUseArrow:
	.byte	$01
	.byte	$01
	.byte	$01
_gameSelectPositionsX:
	.byte	$10
	.byte	$49
	.byte	$10
	.byte	$10
	.byte	$41
	.byte	$10
_gameSelectPositionsY:
	.byte	$3E
	.byte	$3E
	.byte	$5E
	.byte	$7E
	.byte	$7E
	.byte	$8E

.segment	"BSS"

.segment	"ZEROPAGE"
_temp0:
	.res	1,$00
_temp1:
	.res	1,$00
_temp2:
	.res	1,$00
_temp3:
	.res	1,$00
_temp4:
	.res	1,$00
_tempShort0:
	.res	2,$00
_global_i:
	.res	1,$00
_global_j:
	.res	1,$00
_ushort_i:
	.res	2,$00
_frameCount:
	.res	1,$00
_secondsFrameCount:
	.res	1,$00
_rngState:
	.res	2,$00
_prevController:
	.res	1,$00
_controller:
	.res	1,$00
_gameMode:
	.res	1,$00
_cursorX:
	.res	1,$00
_cursorY:
	.res	1,$00
_tempTileX:
	.res	1,$00
_tempTileY:
	.res	1,$00
_numFlags:
	.res	1,$00
_numTilesLeft:
	.res	2,$00
_timePlayedSeconds:
	.res	1,$00
_timePlayedMinutes:
	.res	1,$00
_boardWidth:
	.res	1,$00
_boardHeight:
	.res	1,$00
_maxMines:
	.res	1,$00
_minMines:
	.res	1,$00
_isCustomSeed:
	.res	1,$00
_customSeed:
	.res	2,$00
_checkAdjacentTilesFunction:
	.res	2,$00
.segment	"BSS"
_selectionSprite:
	.res	4,$00
_boardIsMine:
	.res	104,$00
_boardIsActivated:
	.res	104,$00
_boardIsFlag:
	.res	104,$00
_fillStackX:
	.res	64,$00
_fillStackY:
	.res	64,$00
_fillStackPos:
	.res	1,$00
_tileBitShiftOffset:
	.res	1,$00
_attributeTableMirror:
	.res	64,$00
_selectionArrow:
	.res	4,$00
_selectionArrowIndex:
	.res	1,$00
_selectionArrowNumIndices:
	.res	1,$00
_selectionArrowPositionsX:
	.res	2,$00
_selectionArrowPositionsY:
	.res	2,$00
_selectionArrowShouldUseArrow:
	.res	2,$00
_isNumberArrowUp:
	.res	1,$00
_selectionArrowTargetPosX:
	.res	1,$00
_selectionArrowTargetPosY:
	.res	1,$00
_numMines:
	.res	1,$00
_boardSeed:
	.res	2,$00
_boardType:
	.res	2,$00
_debugTemp0:
	.res	1,$00

; ---------------------------------------------------------------
; unsigned char __near__ countMinesAroundTile (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_countMinesAroundTile: near

.segment	"CODE"

;
; temp2 = 0;
;
	lda     #$00
	sta     _temp2
;
; checkAdjacentTilesFunction = _countMines;
;
	lda     #>(__countMines)
	sta     _checkAdjacentTilesFunction+1
	lda     #<(__countMines)
	sta     _checkAdjacentTilesFunction
;
; checkAdjacentTiles();
;
	jsr     _checkAdjacentTiles
;
; return temp2;
;
	ldx     #$00
	lda     _temp2
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ activateTileNoCount (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_activateTileNoCount: near

.segment	"CODE"

;
; if(!getTileIsActivated() && !getTileIsFlag()) {
;
	jsr     _getTileIsActivated
	tax
	bne     L0003
	jsr     _getTileIsFlag
	tax
	beq     L0006
L0003:	rts
;
; setTileIsActivated(TRUE);
;
L0006:	lda     #$01
	jsr     _setTileIsActivated
;
; activateTileBase();
;
	jmp     _activateTileBase

.endproc

; ---------------------------------------------------------------
; void __near__ showTitleScreen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_showTitleScreen: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_fill(BLANK_TILE, 32 * 30);
;
	lda     #$09
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(titleScreenNametable);
;
	lda     #<(_titleScreenNametable)
	ldx     #>(_titleScreenNametable)
	jsr     _vram_unrle
;
; pal_bg(titleScreenBgPalette);
;
	lda     #<(_titleScreenBgPalette)
	ldx     #>(_titleScreenBgPalette)
	jsr     _pal_bg
;
; ppu_on_all();
;
	jmp     _ppu_on_all

.endproc

; ---------------------------------------------------------------
; void __near__ updateController (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateController: near

.segment	"CODE"

;
; prevController = controller;
;
	lda     _controller
	sta     _prevController
;
; controller = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _controller
;
; if(BUTTON_PRESSED(PAD_LEFT) && BUTTON_PRESSED(PAD_RIGHT)) controller &= ~(0b11u);
;
	and     #$02
	beq     L000D
	lda     _controller
	and     #$01
	beq     L000D
	lda     _controller
	and     #$FC
	sta     _controller
;
; if(BUTTON_PRESSED(PAD_UP) && BUTTON_PRESSED(PAD_DOWN)) controller &= ~(0b1100u);
;
L000D:	lda     _controller
	and     #$08
	beq     L000F
	lda     _controller
	and     #$04
	bne     L0010
L000F:	rts
L0010:	lda     _controller
	and     #$F3
	sta     _controller
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ updateRNG (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateRNG: near

.segment	"CODE"

;
; __asm__("lda %v", rngState);
;
	lda     _rngState
;
; __asm__("clc"); //todo maybe remove? depends if carry bit is uncertain at end of frame or not
;
	clc
;
; __asm__("adc %v", controller);
;
	adc     _controller
;
; __asm__("sta %v", rngState);
;
	sta     _rngState
;
; rngState.longState ^= rngState.longState << 7;
;
	ldx     _rngState+1
	jsr     shlax7
	eor     _rngState
	pha
	txa
	eor     _rngState+1
	tax
	pla
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState >> 9;
;
	sta     ptr1
	stx     ptr1+1
	lda     _rngState+1
	lsr     a
	eor     ptr1
	ldx     ptr1+1
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState << 8;
;
	sta     ptr1
	stx     ptr1+1
	ldx     _rngState
	lda     ptr1
	sta     _rngState
	txa
	eor     ptr1+1
	sta     _rngState+1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ updateRNGNoController (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateRNGNoController: near

.segment	"CODE"

;
; rngState.longState ^= rngState.longState << 7;
;
	lda     _rngState
	ldx     _rngState+1
	jsr     shlax7
	eor     _rngState
	pha
	txa
	eor     _rngState+1
	tax
	pla
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState >> 9;
;
	sta     ptr1
	stx     ptr1+1
	lda     _rngState+1
	lsr     a
	eor     ptr1
	ldx     ptr1+1
	sta     _rngState
	stx     _rngState+1
;
; rngState.longState ^= rngState.longState << 8;
;
	sta     ptr1
	stx     ptr1+1
	ldx     _rngState
	lda     ptr1
	sta     _rngState
	txa
	eor     ptr1+1
	sta     _rngState+1
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileBase (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileBase: near

.segment	"CODE"

;
; tempShort0 = ((cursorY << tileBitShiftOffset) + cursorX); //bit offset
;
	ldy     _tileBitShiftOffset
	lda     _cursorY
	ldx     #$00
	jsr     aslaxy
	clc
	adc     _cursorX
	bcc     L0002
	inx
L0002:	sta     _tempShort0
	stx     _tempShort0+1
;
; return (boardType[tempShort0 >> 3] >> (tempShort0 & 0b111u)) & 0b1u;
;
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     shrax3
	clc
	adc     _boardType
	sta     ptr1
	txa
	adc     _boardType+1
	sta     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	lda     _tempShort0
	and     #$07
	tay
	lda     ptr1
L0003:	lsr     a
	dey
	bpl     L0003
	rol     a
	and     #$01
	ldx     #$00
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ setTileBase (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileBase: near

.segment	"CODE"

;
; void setTileBase(uchar value) {
;
	jsr     pusha
;
; tempShort0 = ((cursorY << tileBitShiftOffset) + cursorX); //bit offset
;
	ldy     _tileBitShiftOffset
	lda     _cursorY
	ldx     #$00
	jsr     aslaxy
	clc
	adc     _cursorX
	bcc     L0002
	inx
L0002:	sta     _tempShort0
	stx     _tempShort0+1
;
; temp4 = tempShort0 >> 3;
;
	jsr     shrax3
	sta     _temp4
;
; temp3 = tempShort0 & 0b111;
;
	lda     _tempShort0
	and     #$07
	sta     _temp3
;
; boardType[temp4] = (boardType[temp4] & ~(0b1u << temp3)) | (value << temp3);
;
	lda     _boardType
	ldx     _boardType+1
	clc
	adc     _temp4
	bcc     L0003
	inx
L0003:	sta     ptr2
	stx     ptr2+1
	lda     _boardType
	ldx     _boardType+1
	ldy     _temp4
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     ptr1
	ldy     _temp3
	lda     #$01
L0006:	asl     a
	dey
	bpl     L0006
	ror     a
	eor     #$FF
	and     ptr1
	sta     sreg
	ldy     #$00
	lda     (sp),y
	sta     ptr1
	ldy     _temp3
	lda     ptr1
L0005:	asl     a
	dey
	bpl     L0005
	ror     a
	ora     sreg
	ldy     #$00
	sta     (ptr2),y
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsMine (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsMine: near

.segment	"CODE"

;
; boardType = boardIsMine;
;
	lda     #>(_boardIsMine)
	sta     _boardType+1
	lda     #<(_boardIsMine)
	sta     _boardType
;
; return getTileBase();
;
	jmp     _getTileBase

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsMine (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsMine: near

.segment	"CODE"

;
; inline void setTileIsMine(uchar value) {
;
	jsr     pusha
;
; boardType = boardIsMine;
;
	lda     #>(_boardIsMine)
	sta     _boardType+1
	lda     #<(_boardIsMine)
	sta     _boardType
;
; setTileBase(value);
;
	ldy     #$00
	lda     (sp),y
	jsr     _setTileBase
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsActivated (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsActivated: near

.segment	"CODE"

;
; boardType = boardIsActivated;
;
	lda     #>(_boardIsActivated)
	sta     _boardType+1
	lda     #<(_boardIsActivated)
	sta     _boardType
;
; return getTileBase();
;
	jmp     _getTileBase

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsActivated (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsActivated: near

.segment	"CODE"

;
; inline void setTileIsActivated(uchar value) {
;
	jsr     pusha
;
; boardType = boardIsActivated;
;
	lda     #>(_boardIsActivated)
	sta     _boardType+1
	lda     #<(_boardIsActivated)
	sta     _boardType
;
; setTileBase(value);
;
	ldy     #$00
	lda     (sp),y
	jsr     _setTileBase
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ getTileIsFlag (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_getTileIsFlag: near

.segment	"CODE"

;
; boardType = boardIsFlag;
;
	lda     #>(_boardIsFlag)
	sta     _boardType+1
	lda     #<(_boardIsFlag)
	sta     _boardType
;
; return getTileBase();
;
	jmp     _getTileBase

.endproc

; ---------------------------------------------------------------
; void __near__ setTileIsFlag (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setTileIsFlag: near

.segment	"CODE"

;
; inline void setTileIsFlag(uchar value) {
;
	jsr     pusha
;
; boardType = boardIsFlag;
;
	lda     #>(_boardIsFlag)
	sta     _boardType+1
	lda     #<(_boardIsFlag)
	sta     _boardType
;
; setTileBase(value);
;
	ldy     #$00
	lda     (sp),y
	jsr     _setTileBase
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ printNumber (unsigned char number, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printNumber: near

.segment	"CODE"

;
; void printNumber(uchar number, uchar x, uchar y) {
;
	jsr     pusha
;
; uchar offset = 0; //also for if the number's begun in bit 7 (save a stack variable)
;
	lda     #$00
	jsr     pusha
;
; temp2 = 0;
;
	sta     _temp2
;
; if(number >= 100) {
;
	ldy     #$03
	lda     (sp),y
	cmp     #$64
	lda     #$00
	bcc     L001B
;
; while(number >= 100) {
;
	jmp     L0019
;
; number -= 100;
;
L0017:	lda     (sp),y
	sec
	sbc     #$64
	sta     (sp),y
;
; ++temp2;
;
	inc     _temp2
;
; while(number >= 100) {
;
L0019:	lda     (sp),y
	cmp     #$64
	bcs     L0017
;
; one_vram_buffer(temp2 + NUMBER_TO_TILE, NTADR_A(x, y));
;
	lda     _temp2
	clc
	adc     #$30
	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; offset += 0b10000001;
;
	ldy     #$00
	clc
	lda     #$81
	adc     (sp),y
	sta     (sp),y
;
; temp2 = 0;
;
	tya
L001B:	sta     _temp2
;
; if(number >= 10) {
;
	ldy     #$03
	lda     (sp),y
	cmp     #$0A
	bcc     L0007
;
; while(number >= 10) {
;
	jmp     L001F
;
; number -= 10;
;
L001D:	lda     (sp),y
	sec
	sbc     #$0A
	sta     (sp),y
;
; ++temp2;
;
	inc     _temp2
;
; while(number >= 10) {
;
L001F:	lda     (sp),y
	cmp     #$0A
	bcs     L001D
;
; one_vram_buffer(temp2 + NUMBER_TO_TILE, NTADR_A(x + (offset & 0b11), y));
;
	lda     _temp2
	clc
	adc     #$30
	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	dey
	lda     (sp),y
	ldx     #$00
	and     #$03
	clc
	ldy     #$03
	adc     (sp),y
	bcc     L0012
	inx
L0012:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; offset++;
;
	ldy     #$00
;
; } else if(offset & 0b10000000) offset++;
;
	jmp     L0027
L0007:	ldy     #$00
	lda     (sp),y
	and     #$80
	beq     L0021
L0027:	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; offset &= ~(0b10000000); //clear the has number begun thingy
;
L0021:	lda     (sp),y
	and     #$7F
	sta     (sp),y
;
; one_vram_buffer(number + NUMBER_TO_TILE, NTADR_A(x + offset, y));
;
	ldy     #$03
	lda     (sp),y
	clc
	adc     #$30
	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	dey
	lda     (sp),y
	clc
	ldy     #$03
	adc     (sp),y
	bcc     L0013
	inx
L0013:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; ++offset;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; while(offset < 3) {
;
	jmp     L0024
;
; one_vram_buffer(0x9, NTADR_A(x + offset, y));
;
L0022:	lda     #$09
	jsr     pusha
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	dey
	lda     (sp),y
	clc
	ldy     #$03
	adc     (sp),y
	bcc     L0014
	inx
L0014:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++offset;
;
	ldy     #$00
	clc
	lda     #$01
	adc     (sp),y
	sta     (sp),y
;
; ++temp0;
;
	inc     _temp0
;
; while(offset < 3) {
;
L0024:	lda     (sp),y
	cmp     #$03
	bcc     L0022
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ printHexNumber (unsigned short number, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printHexNumber: near

.segment	"CODE"

;
; void printHexNumber(unsigned short number, uchar x, uchar y) {
;
	jsr     pusha
;
; one_vram_buffer((uchar)(number >> 12) + NUMBER_TO_TILE, NTADR_A(x, y));
;
	ldy     #$03
	lda     (sp),y
	lsr     a
	lsr     a
	lsr     a
	lsr     a
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++x;
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	sta     (sp),y
;
; one_vram_buffer((uchar)((number >> 8) & ~(0b11110000)) + NUMBER_TO_TILE, NTADR_A(x, y));
;
	ldy     #$03
	lda     (sp),y
	and     #$0F
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++x;
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	sta     (sp),y
;
; one_vram_buffer((uchar)((number >> 4) & ~(0b111111110000)) + NUMBER_TO_TILE, NTADR_A(x, y));
;
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     shrax4
	and     #$0F
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++x;
;
	ldy     #$01
	clc
	tya
	adc     (sp),y
	sta     (sp),y
;
; one_vram_buffer((uchar)(number & ~(0b1111111111110000)) + NUMBER_TO_TILE, NTADR_A(x, y));
;
	iny
	lda     (sp),y
	and     #$0F
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; }
;
	jmp     incsp4

.endproc

; ---------------------------------------------------------------
; void __near__ printTime (unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printTime: near

.segment	"CODE"

;
; void printTime(uchar x, uchar y) {
;
	jsr     pusha
;
; if(temp0 > (MAX_SCREEN_UPDATES_PER_FRAME - 12)) return; //ignore if too many pending screen updates
;
	lda     _temp0
	cmp     #$15
	jcs     L000F
;
; temp1 = FALSE; //if there needs to be an extra blank tile at the end
;
	lda     #$00
	sta     _temp1
;
; temp2 = 0; //place counter
;
	sta     _temp2
;
; temp3 = timePlayedMinutes; //copied over from time played so the time played doesn't get modified
;
	lda     _timePlayedMinutes
	sta     _temp3
;
; temp4 = 0; //x offset for vram buffer
;
	lda     #$00
	sta     _temp4
;
; if(timePlayedMinutes >= 10) {
;
	lda     _timePlayedMinutes
	cmp     #$0A
	bcc     L001A
;
; ++temp2;
;
L0019:	inc     _temp2
;
; temp3 -= 10;
;
	lda     _temp3
	sec
	sbc     #$0A
	sta     _temp3
;
; while(temp3 >= 10) {
;
	cmp     #$0A
	bcs     L0019
;
; one_vram_buffer(temp2 + NUMBER_TO_TILE, NTADR_A(x, y));
;
	lda     _temp2
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp4;
;
	inc     _temp4
;
; } else temp1 = TRUE;
;
	jmp     L001B
L001A:	lda     #$01
	sta     _temp1
;
; one_vram_buffer(temp3 + NUMBER_TO_TILE, NTADR_A(x + temp4, y));
;
L001B:	lda     _temp3
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0011
	inx
L0011:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp4;
;
	inc     _temp4
;
; one_vram_buffer(COLON, NTADR_A(x + temp4, y));
;
	lda     #$2D
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0012
	inx
L0012:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp4;
;
	inc     _temp4
;
; temp2 = 0;
;
	lda     #$00
	sta     _temp2
;
; temp3 = timePlayedSeconds; //copied over from time played so the time played doesn't get modified
;
	lda     _timePlayedSeconds
;
; while(temp3 >= 10) {
;
	jmp     L0017
;
; ++temp2;
;
L001C:	inc     _temp2
;
; temp3 -= 10;
;
	lda     _temp3
	sec
	sbc     #$0A
L0017:	sta     _temp3
;
; while(temp3 >= 10) {
;
	cmp     #$0A
	bcs     L001C
;
; one_vram_buffer(temp2 + NUMBER_TO_TILE, NTADR_A(x + temp4, y));
;
	lda     _temp2
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0013
	inx
L0013:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp4;
;
	inc     _temp4
;
; one_vram_buffer(temp3 + NUMBER_TO_TILE, NTADR_A(x + temp4, y));
;
	lda     _temp3
	clc
	adc     #$30
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0014
	inx
L0014:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; if(temp1) one_vram_buffer(BLANK_TILE, NTADR_A(x + temp4 + 1, y));
;
	lda     _temp1
	beq     L000F
	lda     #$09
	jsr     pusha
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	iny
	lda     (sp),y
	clc
	adc     _temp4
	bcc     L0018
	inx
	clc
L0018:	adc     #$01
	bcc     L0010
	inx
L0010:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; }
;
L000F:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ printString (const char *string, unsigned char stringLength, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printString: near

.segment	"CODE"

;
; void printString(const char* string, uchar stringLength, uchar x, uchar y) {
;
	jsr     pusha
;
; multi_vram_buffer_horz(string, stringLength, NTADR_A(x, y));
;
	jsr     decsp3
	ldy     #$07
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$03
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz
;
; }
;
	jmp     incsp5

.endproc

; ---------------------------------------------------------------
; void __near__ printTile (unsigned char tileStart, int address)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_printTile: near

.segment	"CODE"

;
; void printTile(uchar tileStart, int address) {
;
	jsr     pushax
;
; vram_adr(address);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; vram_put(tileStart);
;
	ldy     #$02
	lda     (sp),y
	jsr     _vram_put
;
; vram_put(tileStart + 1);
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     #$01
	jsr     _vram_put
;
; vram_adr(address + 0x20);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$20
	bcc     L0003
	inx
L0003:	jsr     _vram_adr
;
; tileStart += 0x10;
;
	ldy     #$02
	clc
	lda     #$10
	adc     (sp),y
	sta     (sp),y
;
; vram_put(tileStart);
;
	jsr     _vram_put
;
; vram_put(tileStart + 1);
;
	ldy     #$02
	lda     (sp),y
	clc
	adc     #$01
	jsr     _vram_put
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ clearScreen (unsigned char length, unsigned char x, unsigned char y)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_clearScreen: near

.segment	"CODE"

;
; void clearScreen(uchar length, uchar x, uchar y) {
;
	jsr     pusha
;
; multi_vram_buffer_horz_fill(BLANK_TILE, length, NTADR_A(x, y));
;
	jsr     decsp2
	lda     #$09
	ldy     #$01
	sta     (sp),y
	ldy     #$04
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$02
	ldx     #$00
	lda     (sp),y
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	iny
	lda     (sp),y
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_horz_fill
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ clearScreenPrecalculated (unsigned char length, int address)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_clearScreenPrecalculated: near

.segment	"CODE"

;
; inline void clearScreenPrecalculated(uchar length, int address) {
;
	jsr     pushax
;
; multi_vram_buffer_horz_fill(BLANK_TILE, length, address);
;
	jsr     decsp2
	lda     #$09
	ldy     #$01
	sta     (sp),y
	ldy     #$04
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$03
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _multi_vram_buffer_horz_fill
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ checkAdjacentTiles (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_checkAdjacentTiles: near

.segment	"CODE"

;
; if(cursorX == 0) {
;
	lda     _cursorX
	jne     L0018
;
; if(cursorY == 0) {
;
	lda     _cursorY
	bne     L0017
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorY;
;
	inc     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorX;
;
	dec     _cursorX
;
; } else if(cursorY == (boardHeight - 1)) {
;
	jmp     L001C
L0017:	lda     _cursorY
	jsr     pusha0
	lda     _boardHeight
	sec
	sbc     #$01
	bcs     L0006
	ldx     #$FF
L0006:	jsr     tosicmp
	bne     L0005
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorX;
;
	dec     _cursorX
;
; } else {
;
	jmp     L001C
;
; ++cursorY;
;
L0005:	inc     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorX;
;
	dec     _cursorX
;
; } else if(cursorX == (boardWidth - 1)) {
;
	jmp     L001C
L0018:	lda     _cursorX
	jsr     pusha0
	lda     _boardWidth
	sec
	sbc     #$01
	bcs     L000A
	ldx     #$FF
L000A:	jsr     tosicmp
	bne     L0009
;
; if(cursorY == 0) {
;
	lda     _cursorY
	bne     L0019
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorY;
;
	inc     _cursorY
;
; } else if(cursorY == (boardHeight - 1)) {
;
	jmp     L0020
L0019:	lda     _cursorY
	jsr     pusha0
	lda     _boardHeight
	sec
	sbc     #$01
	bcs     L000E
	ldx     #$FF
L000E:	jsr     tosicmp
	bne     L000D
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; } else {
;
	jmp     L0020
;
; ++cursorY;
;
L000D:	inc     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; } else {
;
	jmp     L0020
;
; if(cursorY == 0) {
;
L0009:	lda     _cursorY
	bne     L001A
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorY;
;
	inc     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; } else if(cursorY == (boardHeight - 1)) {
;
	jmp     L001C
L001A:	lda     _cursorY
	jsr     pusha0
	lda     _boardHeight
	sec
	sbc     #$01
	bcs     L0014
	ldx     #$FF
L0014:	jsr     tosicmp
	bne     L0013
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorY;
;
	inc     _cursorY
;
; } else {
;
	jmp     L001C
;
; ++cursorX;
;
L0013:	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorY;
;
	inc     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorX;
;
	dec     _cursorX
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; --cursorY;
;
	dec     _cursorY
;
; checkAdjacentTilesFunction();
;
	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
L0020:	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jsr     callax
;
; ++cursorX;
;
	inc     _cursorX
;
; checkAdjacentTilesFunction();
;
L001C:	lda     _checkAdjacentTilesFunction
	ldx     _checkAdjacentTilesFunction+1
	jmp     callax

.endproc

; ---------------------------------------------------------------
; void __near__ pushCursorXY (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_pushCursorXY: near

.segment	"CODE"

;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ popCursorXY (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_popCursorXY: near

.segment	"CODE"

;
; cursorX = fillStackX[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	sta     _cursorX
;
; cursorY = fillStackY[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackY,y
	sta     _cursorY
;
; --fillStackPos;
;
	dec     _fillStackPos
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ _countMines (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	__countMines: near

.segment	"CODE"

;
; temp2 += getTileIsMine();
;
	jsr     _getTileIsMine
	clc
	adc     _temp2
	sta     _temp2
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ _checkFloodFillPos (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	__checkFloodFillPos: near

.segment	"CODE"

;
; if(!getTileIsMine() && !getTileIsActivated()) {
;
	jsr     _getTileIsMine
	tax
	bne     L0003
	jsr     _getTileIsActivated
	tax
	beq     L0008
L0003:	rts
;
; pushCursorXY();
;
L0008:	jsr     _pushCursorXY
;
; temp2 = countMinesAroundTile();
;
	jsr     _countMinesAroundTile
	sta     _temp2
;
; popCursorXY();
;
	jsr     _popCursorXY
;
; if(temp2 == 0) pushCursorXY();
;
	lda     _temp2
	bne     L0006
	jsr     _pushCursorXY
;
; else activateTileNoCount();
;
	jmp     L0007
L0006:	jsr     _activateTileNoCount
;
; checkAdjacentTilesFunction = _checkFloodFillPos; //checkAdjacentTilesFunction got changed by countMinesAroundTile so change it back
;
L0007:	lda     #>(__checkFloodFillPos)
	sta     _checkAdjacentTilesFunction+1
	lda     #<(__checkFloodFillPos)
	sta     _checkAdjacentTilesFunction
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ _checkPos2 (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	__checkPos2: near

.segment	"CODE"

;
; if(getTileIsFlag()) ++temp2;
;
	jsr     _getTileIsFlag
	tax
	beq     L0002
	inc     _temp2
;
; else pushCursorXY();
;
	rts
L0002:	jmp     _pushCursorXY

.endproc

; ---------------------------------------------------------------
; void __near__ changeAttributeTable (unsigned char value)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_changeAttributeTable: near

.segment	"CODE"

;
; void changeAttributeTable(uchar value) {
;
	jsr     pusha
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = ((cursorY >> 1) << 3) + (cursorX >> 1) + 8;
;
	lda     #<(_fillStackX)
	ldx     #>(_fillStackX)
	clc
	adc     _fillStackPos
	bcc     L0002
	inx
L0002:	sta     sreg
	stx     sreg+1
	lda     _cursorY
	lsr     a
	asl     a
	asl     a
	asl     a
	sta     ptr1
	lda     _cursorX
	lsr     a
	clc
	adc     ptr1
	bcc     L000D
	clc
L000D:	adc     #$08
	ldy     #$00
	sta     (sreg),y
;
; fillStackY[fillStackPos] = (((cursorX & 0b1) << 1) + ((cursorY & 0b1) << 2)); //bit offset
;
	lda     #<(_fillStackY)
	ldx     #>(_fillStackY)
	clc
	adc     _fillStackPos
	bcc     L0004
	inx
L0004:	sta     sreg
	stx     sreg+1
	lda     _cursorX
	ldx     #$00
	and     #$01
	asl     a
	bcc     L000B
	inx
L000B:	sta     ptr1
	stx     ptr1+1
	lda     _cursorY
	ldx     #$00
	and     #$01
	jsr     aslax2
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	pla
	sta     (sreg),y
;
; attributeTableMirror[fillStackX[fillStackPos]] &= (~(0b11 << fillStackY[fillStackPos])); //clear the bits there...
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	clc
	adc     #<(_attributeTableMirror)
	tay
	lda     #$00
	adc     #>(_attributeTableMirror)
	tax
	tya
	sta     sreg
	stx     sreg+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     ptr1
	ldy     _fillStackPos
	lda     _fillStackY,y
	tay
	lda     #$03
L000F:	asl     a
	dey
	bpl     L000F
	ror     a
	eor     #$FF
	and     ptr1
	ldy     #$00
	sta     (sreg),y
;
; attributeTableMirror[fillStackX[fillStackPos]] |= (value << fillStackY[fillStackPos]); //...so they can be set
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	clc
	adc     #<(_attributeTableMirror)
	tay
	lda     #$00
	adc     #>(_attributeTableMirror)
	tax
	tya
	sta     ptr2
	stx     ptr2+1
	sta     ptr1
	stx     ptr1+1
	ldy     #$00
	lda     (ptr1),y
	sta     sreg
	lda     (sp),y
	sta     ptr1
	ldy     _fillStackPos
	lda     _fillStackY,y
	tay
	lda     ptr1
L000E:	asl     a
	dey
	bpl     L000E
	ror     a
	ora     sreg
	ldy     #$00
	sta     (ptr2),y
;
; one_vram_buffer(attributeTableMirror[fillStackX[fillStackPos]], 0x23C0 + fillStackX[fillStackPos]);
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	sta     ptr1
	clc
	lda     #>(_attributeTableMirror)
	sta     ptr1+1
	ldy     #<(_attributeTableMirror)
	lda     (ptr1),y
	jsr     pusha
	ldy     _fillStackPos
	lda     _fillStackX,y
	clc
	adc     #$C0
	pha
	lda     #$00
	adc     #$23
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; --fillStackPos;
;
	dec     _fillStackPos
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ activateTileBase (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_activateTileBase: near

.segment	"CODE"

;
; if(temp0 >= MAX_SCREEN_UPDATES_PER_FRAME) {
;
	lda     _temp0
	cmp     #$20
	bcc     L0021
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; if(IS_GAME_HARD()) {
;
L0021:	lda     _gameMode
	and     #$08
	beq     L0022
;
; one_vram_buffer(temp2 + NUMBER_TO_NUMBER_TILE, NTADR_A(cursorX, cursorY + 4));
;
	lda     _temp2
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	clc
	adc     #$04
	bcc     L0004
	inx
L0004:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; } else {
;
	jmp     L0011
;
; if(temp2 == 8) temp2 = 0x10; //quick hack to get 8-tiles to work properly (they're rare though, so doesn't really matter)
;
L0022:	lda     _temp2
	cmp     #$08
	bne     L0023
	lda     #$10
	sta     _temp2
;
; one_vram_buffer(0x80 + (temp2 << 1), NTADR_A(cursorX << 1, (cursorY << 1) + 4));
;
L0023:	lda     _temp2
	asl     a
	clc
	adc     #$80
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L001B
	inx
	clc
L001B:	adc     #$04
	bcc     L0008
	inx
L0008:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L0014
	inx
L0014:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x81 + (temp2 << 1), NTADR_A((cursorX << 1) + 1, (cursorY << 1) + 4));
;
	lda     _temp2
	asl     a
	clc
	adc     #$81
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L001C
	inx
	clc
L001C:	adc     #$04
	bcc     L000A
	inx
L000A:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L001D
	inx
	clc
L001D:	adc     #$01
	bcc     L000B
	inx
L000B:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x90 + (temp2 << 1), NTADR_A(cursorX << 1, (cursorY << 1) + 5));
;
	lda     _temp2
	asl     a
	clc
	adc     #$90
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L001E
	inx
	clc
L001E:	adc     #$05
	bcc     L000D
	inx
L000D:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L0018
	inx
L0018:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x91 + (temp2 << 1), NTADR_A((cursorX << 1) + 1, (cursorY << 1) + 5));
;
	lda     _temp2
	asl     a
	clc
	adc     #$91
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L001F
	inx
	clc
L001F:	adc     #$05
	bcc     L000F
	inx
L000F:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L0020
	inx
	clc
L0020:	adc     #$01
	bcc     L0010
	inx
L0010:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; changeAttributeTable(0b11);
;
	lda     #$03
	jsr     _changeAttributeTable
;
; temp0 += 5;
;
	lda     #$05
	clc
	adc     _temp0
	sta     _temp0
;
; if(temp2 == 0x10) temp2 = 8; //restore temp2 if it got clobbered from the 8-tile shenanigans
;
	lda     _temp2
	cmp     #$10
	bne     L0011
	lda     #$08
	sta     _temp2
;
; --numTilesLeft;
;
L0011:	ldx     _numTilesLeft
	bne     L0012
	dec     _numTilesLeft+1
L0012:	dex
	stx     _numTilesLeft
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ activateTile (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_activateTile: near

.segment	"CODE"

;
; if(!getTileIsActivated()) {
;
	jsr     _getTileIsActivated
	tax
	bne     L0002
;
; setTileIsActivated(TRUE);
;
	lda     #$01
	jsr     _setTileIsActivated
;
; countMinesAroundTile();
;
	jsr     _countMinesAroundTile
;
; activateTileBase();
;
	jmp     _activateTileBase
;
; }
;
L0002:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ floodFillZeros (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_floodFillZeros: near

.segment	"CODE"

;
; unsigned char currentStackPos = fillStackPos;
;
	lda     _fillStackPos
	jsr     pusha
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = tempTileX;
;
	ldy     _fillStackPos
	lda     _tempTileX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = tempTileY;
;
	ldy     _fillStackPos
	lda     _tempTileY
	sta     _fillStackY,y
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; while(fillStackPos != currentStackPos) {
;
	jmp     L002A
;
; cursorX = fillStackX[fillStackPos];
;
L0004:	ldy     _fillStackPos
	lda     _fillStackX,y
	sta     _cursorX
;
; cursorY = fillStackY[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackY,y
	sta     _cursorY
;
; --fillStackPos;
;
	dec     _fillStackPos
;
; if(fillStackPos >= (FILL_STACK_SIZE - 0x4)) {
;
	lda     _fillStackPos
	cmp     #$3C
	bcc     L0009
;
; fillStackPos = currentStackPos + 1;
;
	ldy     #$00
	lda     (sp),y
	clc
	adc     #$01
	sta     _fillStackPos
;
; fillStackX[fillStackPos] = cursorX;
;
	ldy     _fillStackPos
	lda     _cursorX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = cursorY;
;
	ldy     _fillStackPos
	lda     _cursorY
	sta     _fillStackY,y
;
; if(getTileIsActivated()) continue;
;
L0009:	jsr     _getTileIsActivated
	tax
	jne     L002A
;
; if(!getTileIsFlag()) {
;
	jsr     _getTileIsFlag
	tax
	jne     L000E
;
; setTileIsActivated(TRUE);
;
	lda     #$01
	jsr     _setTileIsActivated
;
; if(temp0 >= MAX_SCREEN_UPDATES_PER_FRAME) {
;
	lda     _temp0
	cmp     #$20
	bcc     L0028
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; if(IS_GAME_HARD()) {
;
L0028:	lda     _gameMode
	and     #$08
	beq     L0029
;
; one_vram_buffer(NUMBER_TO_NUMBER_TILE, NTADR_A(cursorX, cursorY + 4));
;
	lda     #$00
	jsr     pusha
	tax
	lda     _cursorY
	clc
	adc     #$04
	bcc     L0011
	inx
L0011:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; } else {
;
	jmp     L0012
;
; one_vram_buffer(0x80, NTADR_A(cursorX << 1, (cursorY << 1) + 4));
;
L0029:	lda     #$80
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L0022
	inx
	clc
L0022:	adc     #$04
	bcc     L0013
	inx
L0013:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L001B
	inx
L001B:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x81, NTADR_A((cursorX << 1) + 1, (cursorY << 1) + 4));
;
	lda     #$81
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L0023
	inx
	clc
L0023:	adc     #$04
	bcc     L0014
	inx
L0014:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L0024
	inx
	clc
L0024:	adc     #$01
	bcc     L0015
	inx
L0015:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x90, NTADR_A(cursorX << 1, (cursorY << 1) + 5));
;
	lda     #$90
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L0025
	inx
	clc
L0025:	adc     #$05
	bcc     L0016
	inx
L0016:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L001F
	inx
L001F:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x91, NTADR_A((cursorX << 1) + 1, (cursorY << 1) + 5));
;
	lda     #$91
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	asl     a
	bcc     L0026
	inx
	clc
L0026:	adc     #$05
	bcc     L0017
	inx
L0017:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _cursorX
	asl     a
	bcc     L0027
	inx
	clc
L0027:	adc     #$01
	bcc     L0018
	inx
L0018:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; changeAttributeTable(0b11);
;
	lda     #$03
	jsr     _changeAttributeTable
;
; temp0 += 5;
;
	lda     #$05
	clc
	adc     _temp0
	sta     _temp0
;
; --numTilesLeft;
;
L0012:	ldx     _numTilesLeft
	bne     L0019
	dec     _numTilesLeft+1
L0019:	dex
	stx     _numTilesLeft
;
; checkAdjacentTilesFunction = _checkFloodFillPos;
;
L000E:	lda     #>(__checkFloodFillPos)
	sta     _checkAdjacentTilesFunction+1
	lda     #<(__checkFloodFillPos)
	sta     _checkAdjacentTilesFunction
;
; checkAdjacentTiles();
;
	jsr     _checkAdjacentTiles
;
; while(fillStackPos != currentStackPos) {
;
L002A:	lda     _fillStackPos
	ldy     #$00
	cmp     (sp),y
	jne     L0004
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ gameUpdateDifficultyIndependent (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gameUpdateDifficultyIndependent: near

.segment	"CODE"

;
; if(debugTemp0) {
;
	lda     _debugTemp0
	beq     L0064
;
; --debugTemp0;
;
	dec     _debugTemp0
;
; if(!debugTemp0) one_vram_buffer(0x09, PALETTE_MEMORY_BEGIN + 0x0); //make the screen normal again
;
	bne     L0064
	lda     #$09
	jsr     pusha
	ldx     #$3F
	lda     #$00
	jsr     _one_vram_buffer
;
; if(BUTTON_DOWN(PAD_RIGHT)) {
;
L0064:	lda     _controller
	and     #$01
	beq     L0068
	lda     _prevController
	and     #$01
	bne     L0068
;
; __asm__("ldx %v", cursorX);
;
	ldx     _cursorX
;
; __asm__("inx");
;
	inx
;
; __asm__("cpx %v", boardWidth);
;
	cpx     _boardWidth
;
; __asm__("bne @padRightSkip");
;
	bne     @padRightSkip
;
; __asm__("ldx #$00");
;
	tax
;
; __asm__("stx %v", cursorX);
;
@padRightSkip:
	stx     _cursorX
;
; if(BUTTON_DOWN(PAD_LEFT)) {
;
L0068:	lda     _controller
	and     #$02
	beq     L006C
	lda     _prevController
	and     #$02
	bne     L006C
;
; __asm__("ldx %v", cursorX);
;
	ldx     _cursorX
;
; __asm__("dex");
;
	dex
;
; __asm__("bpl @padLeftSkip");
;
	bpl     @padLeftSkip
;
; __asm__("ldx %v", boardWidth);
;
	ldx     _boardWidth
;
; __asm__("dex");
;
	dex
;
; __asm__("stx %v", cursorX);
;
@padLeftSkip:
	stx     _cursorX
;
; if(BUTTON_DOWN(PAD_DOWN)) {
;
L006C:	lda     _controller
	and     #$04
	beq     L0070
	lda     _prevController
	and     #$04
	bne     L0070
;
; __asm__("ldx %v", cursorY);
;
	ldx     _cursorY
;
; __asm__("inx");
;
	inx
;
; __asm__("cpx %v", boardHeight);
;
	cpx     _boardHeight
;
; __asm__("bne @padDownSkip");
;
	bne     @padDownSkip
;
; __asm__("ldx #00");
;
	tax
;
; __asm__("stx %v", cursorY);
;
@padDownSkip:
	stx     _cursorY
;
; if(BUTTON_DOWN(PAD_UP)) {
;
L0070:	lda     _controller
	and     #$08
	beq     L0074
	lda     _prevController
	and     #$08
	bne     L0074
;
; __asm__("ldx %v", cursorY);
;
	ldx     _cursorY
;
; __asm__("dex");
;
	dex
;
; __asm__("bpl @padUpSkip");
;
	bpl     @padUpSkip
;
; __asm__("ldx %v", boardHeight);
;
	ldx     _boardHeight
;
; __asm__("dex");
;
	dex
;
; __asm__("stx %v", cursorY);
;
@padUpSkip:
	stx     _cursorY
;
; if((frameCount & 0b11111) == 0) {
;
L0074:	lda     _frameCount
	and     #$1F
	bne     L0076
;
; if((frameCount & 0b111111) == 0) one_vram_buffer(WHITE, PALETTE_MEMORY_BEGIN + 0x11);
;
	lda     _frameCount
	and     #$3F
	bne     L0075
	lda     #$30
;
; else one_vram_buffer(0x38, PALETTE_MEMORY_BEGIN + 0x11);
;
	jmp     L009A
L0075:	lda     #$38
L009A:	jsr     pusha
	ldx     #$3F
	lda     #$11
	jsr     _one_vram_buffer
;
; if(BUTTON_DOWN(PAD_B) && !getTileIsActivated()) {
;
L0076:	lda     _controller
	and     #$40
	jeq     L007D
	lda     _prevController
	and     #$40
	jne     L007D
	jsr     _getTileIsActivated
	tax
	jne     L007D
;
; if(getTileIsFlag()) {
;
	jsr     _getTileIsFlag
	tax
	jeq     L007B
;
; ++numFlags;
;
	inc     _numFlags
;
; setTileIsFlag(FALSE);
;
	lda     #$00
	jsr     _setTileIsFlag
;
; if(IS_GAME_HARD()) {
;
	lda     _gameMode
	and     #$08
	beq     L007A
;
; one_vram_buffer(0x9 + (((cursorX & 0b1) ^ (cursorY & 0b1)) << 1), NTADR_A(cursorX, cursorY + 4));
;
	lda     _cursorX
	and     #$01
	jsr     pusha0
	lda     _cursorY
	and     #$01
	jsr     tosxora0
	asl     a
	clc
	adc     #$09
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	clc
	adc     #$04
	bcc     L0020
	inx
L0020:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; } else {
;
	jmp     L002A
;
; temp1 = cursorX << 1;
;
L007A:	lda     _cursorX
	asl     a
	sta     _temp1
;
; temp3 = (cursorY << 1) + 4;
;
	lda     _cursorY
	asl     a
	clc
	adc     #$04
	sta     _temp3
;
; one_vram_buffer(0xA2, NTADR_A(temp1, temp3));
;
	lda     #$A2
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _temp1
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0xA3, NTADR_A(temp1 + 1, temp3));
;
	lda     #$A3
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _temp1
	clc
	adc     #$01
	bcc     L0023
	inx
L0023:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp3;
;
	inc     _temp3
;
; one_vram_buffer(0xB2, NTADR_A(temp1, temp3));
;
	lda     #$B2
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _temp1
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0xB3, NTADR_A(temp1 + 1, temp3));
;
	lda     #$B3
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _temp1
	clc
	adc     #$01
	bcc     L0024
	inx
L0024:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; changeAttributeTable(0b01);
;
	lda     #$01
;
; } else if(numFlags > 0) {
;
	jmp     L009C
L007B:	lda     _numFlags
	jeq     L002A
;
; --numFlags;
;
	dec     _numFlags
;
; setTileIsFlag(TRUE);
;
	lda     #$01
	jsr     _setTileIsFlag
;
; gameMode |= (0b1 << 6); //set that a flag was put down
;
	lda     _gameMode
	ora     #$40
	sta     _gameMode
;
; if(IS_GAME_HARD()) {
;
	and     #$08
	beq     L007C
;
; one_vram_buffer(0xA + (((cursorX & 0b1) ^ (cursorY & 0b1)) << 1), NTADR_A(cursorX, cursorY + 4));
;
	lda     _cursorX
	and     #$01
	jsr     pusha0
	lda     _cursorY
	and     #$01
	jsr     tosxora0
	asl     a
	clc
	adc     #$0A
	jsr     pusha
	ldx     #$00
	lda     _cursorY
	clc
	adc     #$04
	bcc     L0029
	inx
L0029:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _cursorX
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp0;
;
	inc     _temp0
;
; } else {
;
	jmp     L002A
;
; temp1 = cursorX << 1;
;
L007C:	lda     _cursorX
	asl     a
	sta     _temp1
;
; temp3 = (cursorY << 1) + 4;
;
	lda     _cursorY
	asl     a
	clc
	adc     #$04
	sta     _temp3
;
; one_vram_buffer(0xA4, NTADR_A(temp1, temp3));
;
	lda     #$A4
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _temp1
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0xA5, NTADR_A(temp1 + 1, temp3));
;
	lda     #$A5
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _temp1
	clc
	adc     #$01
	bcc     L002C
	inx
L002C:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; ++temp3;
;
	inc     _temp3
;
; one_vram_buffer(0xB4, NTADR_A(temp1, temp3));
;
	lda     #$B4
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _temp1
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; one_vram_buffer(0xB5, NTADR_A(temp1 + 1, temp3));
;
	lda     #$B5
	jsr     pusha
	ldx     #$00
	lda     _temp3
	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _temp1
	clc
	adc     #$01
	bcc     L002D
	inx
L002D:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; changeAttributeTable(0b10);
;
	lda     #$02
L009C:	jsr     _changeAttributeTable
;
; temp0 += 5;
;
	lda     #$05
	clc
	adc     _temp0
	sta     _temp0
;
; printNumber(numFlags, 2, 3);
;
L002A:	jsr     decsp2
	lda     _numFlags
	ldy     #$01
	sta     (sp),y
	lda     #$02
	dey
	sta     (sp),y
	lda     #$03
	jsr     _printNumber
;
; tempTileX = cursorX;
;
L007D:	lda     _cursorX
	sta     _tempTileX
;
; tempTileY = cursorY;
;
	lda     _cursorY
	sta     _tempTileY
;
; if(!getTileIsFlag() && !getTileIsActivated()) {
;
	jsr     _getTileIsFlag
	tax
	bne     L0083
	jsr     _getTileIsActivated
	tax
	bne     L0083
;
; if(BUTTON_DOWN(PAD_A)) {
;
	lda     _controller
	and     #$80
	beq     L0082
	lda     _prevController
	and     #$80
	bne     L0082
;
; if(getTileIsMine()) {
;
	jsr     _getTileIsMine
	tax
	beq     L0036
;
; one_vram_buffer(0x06, PALETTE_MEMORY_BEGIN + 0x0); //second of all, make the screen red (temp, todo remove)
;
	lda     #$06
	jsr     pusha
	ldx     #$3F
	lda     #$00
	jsr     _one_vram_buffer
;
; debugTemp0 = 5;
;
	lda     #$05
	sta     _debugTemp0
;
; } else {
;
	jmp     L0082
;
; pushCursorXY();
;
L0036:	jsr     _pushCursorXY
;
; countMinesAroundTile();
;
	jsr     _countMinesAroundTile
;
; popCursorXY();
;
	jsr     _popCursorXY
;
; if(temp2 == 0) floodFillZeros(); //enjoy
;
	lda     _temp2
	bne     L0038
	jsr     _floodFillZeros
;
; else activateTileNoCount();
;
	jmp     L0082
L0038:	jsr     _activateTileNoCount
;
; cursorX = tempTileX;
;
L0082:	lda     _tempTileX
	sta     _cursorX
;
; cursorY = tempTileY;
;
	lda     _tempTileY
	sta     _cursorY
;
; if(BUTTON_DOWN(PAD_SELECT) && getTileIsActivated()) {
;
L0083:	lda     _controller
	and     #$20
	jeq     L003A
	lda     _prevController
	and     #$20
	jne     L003A
	jsr     _getTileIsActivated
	tax
	jeq     L003A
;
; pushCursorXY();
;
	jsr     _pushCursorXY
;
; temp2 = countMinesAroundTile();
;
	jsr     _countMinesAroundTile
	sta     _temp2
;
; popCursorXY();
;
	jsr     _popCursorXY
;
; temp1 = temp2;
;
	lda     _temp2
	sta     _temp1
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = 0xFF; //end of list of non-mine tiles
;
	ldy     _fillStackPos
	lda     #$FF
	sta     _fillStackX,y
;
; temp2 = 0;
;
	lda     #$00
	sta     _temp2
;
; checkAdjacentTilesFunction = _checkPos2;
;
	lda     #>(__checkPos2)
	sta     _checkAdjacentTilesFunction+1
	lda     #<(__checkPos2)
	sta     _checkAdjacentTilesFunction
;
; checkAdjacentTiles();
;
	jsr     _checkAdjacentTiles
;
; if(temp2 == temp1) {
;
	lda     _temp2
	cmp     _temp1
	bne     L0086
;
; while(fillStackX[fillStackPos] != 0xFF) {
;
	jmp     L0045
;
; popCursorXY();
;
L0040:	jsr     _popCursorXY
;
; if(getTileIsMine()) {
;
	jsr     _getTileIsMine
	tax
	beq     L0044
;
; one_vram_buffer(0x06, PALETTE_MEMORY_BEGIN + 0x0); //second of all, make the screen red (temp, todo remove, make screen be destroyed)
;
	lda     #$06
	jsr     pusha
	ldx     #$3F
	lda     #$00
	jsr     _one_vram_buffer
;
; debugTemp0 = 5;
;
	lda     #$05
	sta     _debugTemp0
;
; } else {
;
	jmp     L0045
;
; pushCursorXY();
;
L0044:	jsr     _pushCursorXY
;
; countMinesAroundTile();
;
	jsr     _countMinesAroundTile
;
; popCursorXY();
;
	jsr     _popCursorXY
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = tempTileX;
;
	ldy     _fillStackPos
	lda     _tempTileX
	sta     _fillStackX,y
;
; fillStackY[fillStackPos] = tempTileY;
;
	ldy     _fillStackPos
	lda     _tempTileY
	sta     _fillStackY,y
;
; tempTileX = cursorX;
;
	lda     _cursorX
	sta     _tempTileX
;
; tempTileY = cursorY;
;
	lda     _cursorY
	sta     _tempTileY
;
; if(temp2 == 0) floodFillZeros();
;
	lda     _temp2
	bne     L0048
	jsr     _floodFillZeros
;
; else activateTileNoCount();
;
	jmp     L0049
L0048:	jsr     _activateTileNoCount
;
; tempTileX = fillStackX[fillStackPos];
;
L0049:	ldy     _fillStackPos
	lda     _fillStackX,y
	sta     _tempTileX
;
; tempTileY = fillStackY[fillStackPos];
;
	ldy     _fillStackPos
	lda     _fillStackY,y
	sta     _tempTileY
;
; --fillStackPos;
;
	dec     _fillStackPos
;
; while(fillStackX[fillStackPos] != 0xFF) {
;
L0045:	ldy     _fillStackPos
	lda     _fillStackX,y
	cmp     #$FF
	bne     L0040
;
; --fillStackPos;
;
	dec     _fillStackPos
;
; cursorX = tempTileX;
;
L0086:	lda     _tempTileX
	sta     _cursorX
;
; cursorY = tempTileY;
;
	lda     _tempTileY
	sta     _cursorY
;
; if(numTilesLeft == 0) {
;
L003A:	lda     _numTilesLeft
	ora     _numTilesLeft+1
	jne     L008D
;
; oam_clear();
;
	jsr     _oam_clear
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; color_emphasis(COL_EMP_GREEN);
;
	lda     #$40
	jsr     _color_emphasis
;
; pal_bg_bright(7);
;
	lda     #$07
	jsr     _pal_bg_bright
;
; delay(NUM_FLASH_FRAMES);
;
	lda     #$03
	jsr     _delay
;
; color_emphasis(COL_EMP_NORMAL);
;
	lda     #$00
	jsr     _color_emphasis
;
; pal_bright(4);
;
	lda     #$04
	jsr     _pal_bright
;
; delay(NUM_WAIT_FRAMES);
;
	lda     #$4B
	jsr     _delay
;
; pal_fade_to(4, 0);
;
	lda     #$04
	jsr     pusha
	lda     #$00
	jsr     _pal_fade_to
;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_fill(BLANK_TILE, 32 * 30);
;
	lda     #$09
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(gameEndScreenNametable);
;
	lda     #<(_gameEndScreenNametable)
	ldx     #>(_gameEndScreenNametable)
	jsr     _vram_unrle
;
; pal_bg(gameEndPalette);
;
	lda     #<(_gameEndPalette)
	ldx     #>(_gameEndPalette)
	jsr     _pal_bg
;
; if(!IS_GAME_HARD()) {
;
	lda     _gameMode
	and     #$08
	bne     L0087
;
; vram_adr(NTADR_A(18, 12));
;
	ldx     #$21
	lda     #$92
	jsr     _vram_adr
;
; vram_put(0x82);
;
	lda     #$82
	jsr     _vram_put
;
; vram_put(0x83);
;
	lda     #$83
	jsr     _vram_put
;
; vram_adr(NTADR_A(18, 13));
;
	ldx     #$21
	lda     #$B2
	jsr     _vram_adr
;
; vram_put(0x92);
;
	lda     #$92
	jsr     _vram_put
;
; vram_put(0x93);
;
	lda     #$93
	jsr     _vram_put
;
; vram_adr(0x23DC);
;
	ldx     #$23
	lda     #$DC
	jsr     _vram_adr
;
; vram_put(0b01001100);
;
	lda     #$4C
	jsr     _vram_put
;
; if(!(gameMode & (0b1 << 6))) {
;
L0087:	lda     _gameMode
	and     #$40
	bne     L0088
;
; vram_adr(NTADR_A(18, 14));
;
	ldx     #$21
	lda     #$D2
	jsr     _vram_adr
;
; vram_put(0xA6);
;
	lda     #$A6
	jsr     _vram_put
;
; vram_put(0xA7);
;
	lda     #$A7
	jsr     _vram_put
;
; vram_adr(NTADR_A(18, 15));
;
	ldx     #$21
	lda     #$F2
	jsr     _vram_adr
;
; vram_put(0xB6);
;
	lda     #$B6
	jsr     _vram_put
;
; vram_put(0xB7);
;
	lda     #$B7
	jsr     _vram_put
;
; if(gameMode & (0b1 << 4)) {
;
L0088:	lda     _gameMode
	and     #$10
	beq     L008A
;
; vram_adr(NTADR_A(18, 16));
;
	ldx     #$22
	lda     #$12
	jsr     _vram_adr
;
; vram_put(0xA8);
;
	lda     #$A8
	jsr     _vram_put
;
; vram_put(0xA9);
;
	lda     #$A9
	jsr     _vram_put
;
; vram_adr(NTADR_A(18, 17));
;
	ldx     #$22
	lda     #$32
	jsr     _vram_adr
;
; vram_put(0xB8);
;
	lda     #$B8
	jsr     _vram_put
;
; vram_put(0xB9);
;
	lda     #$B9
	jsr     _vram_put
;
; pal_bright(0);
;
	lda     #$00
L008A:	jsr     _pal_bright
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; one_vram_buffer(0b00001100, 0x23F4);
;
	lda     #$0C
	jsr     pusha
	ldx     #$23
	lda     #$F4
	jsr     _one_vram_buffer
;
; printString(youWonText, sizeof(youWonText), 12, 10);
;
	jsr     decsp4
	lda     #<(_youWonText)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_youWonText)
	sta     (sp),y
	lda     #$08
	ldy     #$01
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #$0A
	jsr     _printString
;
; printTime(11, 14);
;
	lda     #$0B
	jsr     pusha
	lda     #$0E
	jsr     _printTime
;
; printHexNumber(boardSeed, 11, 18);
;
	jsr     decsp3
	lda     _boardSeed
	ldy     #$01
	sta     (sp),y
	iny
	lda     _boardSeed+1
	sta     (sp),y
	lda     #$0B
	ldy     #$00
	sta     (sp),y
	lda     #$12
	jsr     _printHexNumber
;
; one_vram_buffer(OPENING_BRACKET, NTADR_A(16, 18));
;
	lda     #$5D
	jsr     pusha
	ldx     #$22
	lda     #$50
	jsr     _one_vram_buffer
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; printNumber(numMines, 17, 18);
;
	jsr     decsp2
	lda     _numMines
	ldy     #$01
	sta     (sp),y
	lda     #$11
	dey
	sta     (sp),y
	lda     #$12
	jsr     _printNumber
;
; if(numMines < 10) temp1 = 1;
;
	lda     _numMines
	cmp     #$0A
	bcs     L008B
	lda     #$01
;
; else if(numMines < 100) temp1 = 2;
;
	jmp     L0061
L008B:	lda     _numMines
	cmp     #$64
	bcs     L008C
	lda     #$02
;
; else temp1 = 3;
;
	jmp     L0061
L008C:	lda     #$03
L0061:	sta     _temp1
;
; one_vram_buffer(CLOSING_BRACKET, NTADR_A(17 + temp1, 18));
;
	lda     #$5E
	jsr     pusha
	ldx     #$00
	lda     _temp1
	clc
	adc     #$11
	bcc     L0055
	inx
L0055:	ora     #$40
	pha
	txa
	ora     #$02
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; delay(60);
;
	lda     #$3C
	jsr     _delay
;
; pal_fade_to(0, 4);
;
	lda     #$00
	jsr     pusha
	lda     #$04
	jsr     _pal_fade_to
;
; gameMode &= ~(0b111); //set to game end screen
;
	lda     _gameMode
	and     #$F8
	sta     _gameMode
;
; gameMode |= 0b011;
;
	ora     #$03
	sta     _gameMode
;
; temp0 = TRUE;
;
	lda     #$01
;
; return;
;
	jmp     L0062
;
; if(BUTTON_DOWN(PAD_START)) {
;
L008D:	lda     _controller
	and     #$10
	jeq     L0092
	lda     _prevController
	and     #$10
	jne     L0092
;
; if(temp0 > 0) {
;
	lda     _temp0
	beq     L0091
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; gameMode |= (0b1 << 5); //make the gamemode paused
;
L0091:	lda     _gameMode
	ora     #$20
	sta     _gameMode
;
; selectionArrowIndex = 0;
;
	lda     #$00
	sta     _selectionArrowIndex
;
; selectionArrowNumIndices = sizeof(gamePauseMenuPositionsX);
;
	lda     #$03
	sta     _selectionArrowNumIndices
;
; selectionArrowPositionsX = gamePauseMenuPositionsX;
;
	lda     #>(_gamePauseMenuPositionsX)
	sta     _selectionArrowPositionsX+1
	lda     #<(_gamePauseMenuPositionsX)
	sta     _selectionArrowPositionsX
;
; selectionArrowPositionsY = gamePauseMenuPositionsY;
;
	lda     #>(_gamePauseMenuPositionsY)
	sta     _selectionArrowPositionsY+1
	lda     #<(_gamePauseMenuPositionsY)
	sta     _selectionArrowPositionsY
;
; selectionArrowShouldUseArrow = gamePauseMenuShouldUseArrow;
;
	lda     #>(_gamePauseMenuShouldUseArrow)
	sta     _selectionArrowShouldUseArrow+1
	lda     #<(_gamePauseMenuShouldUseArrow)
	sta     _selectionArrowShouldUseArrow
;
; printString(pausedText, sizeof(pausedText), 12, 1);
;
	jsr     decsp4
	lda     #<(_pausedText)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_pausedText)
	sta     (sp),y
	lda     #$06
	ldy     #$01
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #$01
	jsr     _printString
;
; printString(backText, sizeof(backText), 13, 2);
;
	jsr     decsp4
	lda     #<(_backText)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_backText)
	sta     (sp),y
	lda     #$0C
	ldy     #$01
	sta     (sp),y
	lda     #$0D
	dey
	sta     (sp),y
	lda     #$02
	jsr     _printString
;
; printString(newGameText, sizeof(newGameText), 13, 3);
;
	jsr     decsp4
	lda     #<(_newGameText)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_newGameText)
	sta     (sp),y
	lda     #$08
	ldy     #$01
	sta     (sp),y
	lda     #$0D
	dey
	sta     (sp),y
	lda     #$03
	jsr     _printString
;
; printString(leaveText, sizeof(leaveText), 27, 2);
;
	jsr     decsp4
	lda     #<(_leaveText)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_leaveText)
	sta     (sp),y
	lda     #$04
	ldy     #$01
	sta     (sp),y
	lda     #$1B
	dey
	sta     (sp),y
	lda     #$02
	jsr     _printString
;
; selectionArrow.xPos = gamePauseMenuPositionsX[0];
;
	lda     _gamePauseMenuPositionsX
	sta     _selectionArrow+3
;
; selectionArrow.yPos = gamePauseMenuPositionsY[0];
;
	lda     _gamePauseMenuPositionsY
	sta     _selectionArrow
;
; ++secondsFrameCount;
;
L0092:	inc     _secondsFrameCount
;
; if(secondsFrameCount == 60) {
;
	lda     _secondsFrameCount
	cmp     #$3C
	bne     L0095
;
; secondsFrameCount = 0;
;
	lda     #$00
	sta     _secondsFrameCount
;
; ++timePlayedSeconds;
;
	inc     _timePlayedSeconds
;
; if(timePlayedSeconds == 60) {
;
	lda     _timePlayedSeconds
	cmp     #$3C
	bne     L0094
;
; ++timePlayedMinutes;
;
	inc     _timePlayedMinutes
;
; if(timePlayedMinutes == 60) { //cap the timer at 59:59
;
	lda     _timePlayedMinutes
	cmp     #$3C
	bne     L0093
;
; timePlayedMinutes = 59;
;
	lda     #$3B
	sta     _timePlayedMinutes
;
; } else timePlayedSeconds = 0;
;
	jmp     L0063
L0093:	lda     #$00
L0063:	sta     _timePlayedSeconds
;
; printTime(7, 3);
;
L0094:	lda     #$07
	jsr     pusha
	lda     #$03
	jsr     _printTime
;
; temp0 = FALSE;
;
L0095:	lda     #$00
L0062:	sta     _temp0
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ gameUpdateHard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gameUpdateHard: near

.segment	"CODE"

;
; if(temp0) {
;
	lda     _temp0
	beq     L0002
;
; temp0 = FALSE;
;
	lda     #$00
	sta     _temp0
;
; return;
;
	rts
;
; selectionSprite.hardSelectionSprite.xPos = cursorX << 3; //x8 to align w/ tiles
;
L0002:	lda     _cursorX
	asl     a
	asl     a
	asl     a
	sta     _selectionSprite+3
;
; selectionSprite.hardSelectionSprite.yPos = (cursorY << 3) + 31; //1 less to be 1 higher (properly aligned)
;
	lda     _cursorY
	asl     a
	asl     a
	asl     a
	clc
	adc     #$1F
	sta     _selectionSprite
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_spr(selectionSprite.hardSelectionSprite.xPos, selectionSprite.hardSelectionSprite.yPos,
;
	jsr     decsp3
	lda     _selectionSprite+3
	ldy     #$02
	sta     (sp),y
	lda     _selectionSprite
	dey
	sta     (sp),y
;
; selectionSprite.hardSelectionSprite.tile, selectionSprite.hardSelectionSprite.attributes);
;
	lda     _selectionSprite+1
	dey
	sta     (sp),y
	lda     _selectionSprite+2
	jmp     _oam_spr

.endproc

; ---------------------------------------------------------------
; void __near__ gameUpdateEasy (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gameUpdateEasy: near

.segment	"CODE"

;
; if(temp0) {
;
	lda     _temp0
	beq     L0002
;
; temp0 = FALSE;
;
	lda     #$00
	sta     _temp0
;
; return;
;
	rts
;
; selectionSprite.easySelectionSprite.xPos = cursorX << 4;
;
L0002:	lda     _cursorX
	asl     a
	asl     a
	asl     a
	asl     a
	sta     _selectionSprite+3
;
; selectionSprite.easySelectionSprite.yPos = (cursorY << 4) + 31; //1 less to be 1 higher (properly aligned)
;
	lda     _cursorY
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$1F
	sta     _selectionSprite
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_meta_spr(selectionSprite.easySelectionSprite.xPos, selectionSprite.easySelectionSprite.yPos, easySelectorMetasprite);
;
	jsr     decsp2
	lda     _selectionSprite+3
	ldy     #$01
	sta     (sp),y
	lda     _selectionSprite
	dey
	sta     (sp),y
	lda     #<(_easySelectorMetasprite)
	ldx     #>(_easySelectorMetasprite)
	jmp     _oam_meta_spr

.endproc

; ---------------------------------------------------------------
; void __near__ generateBoard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_generateBoard: near

.segment	"CODE"

;
; if(IS_GAME_HARD()) {
;
	lda     _gameMode
	and     #$08
	beq     L0014
;
; temp0 = numMines; //200 mines by default
;
	lda     _numMines
	sta     _temp0
;
; numFlags = numMines;
;
	sta     _numFlags
;
; numTilesLeft = (HARD_MAX_X * HARD_MAX_Y) - numMines;
;
	lda     #$20
	sec
	sbc     _numMines
	sta     _numTilesLeft
	lda     #$03
	sbc     #$00
	sta     _numTilesLeft+1
;
; temp1 = HARD_MAX_Y;
;
	lda     #$19
	sta     _temp1
;
; temp2 = BOARD_MEM_SIZE;
;
	lda     #$68
	sta     _temp2
;
; tempShort0 = HARD_MAX_X * HARD_MAX_Y;
;
	ldx     #$03
	lda     #$20
;
; } else { //otherwise game is in easy mode
;
	jmp     L0018
;
; temp0 = numMines; //60 mines by default
;
L0014:	lda     _numMines
	sta     _temp0
;
; numFlags = numMines;
;
	sta     _numFlags
;
; numTilesLeft = (EASY_MAX_X * EASY_MAX_Y) - numMines;
;
	lda     #$C0
	sec
	sbc     _numMines
	ldx     #$00
	bcs     L0012
	dex
L0012:	sta     _numTilesLeft
	stx     _numTilesLeft+1
;
; temp1 = EASY_MAX_Y;
;
	lda     #$0C
	sta     _temp1
;
; temp2 = EASY_BOARD_USED_MEM_SIZE;
;
	lda     #$1A
	sta     _temp2
;
; tempShort0 = EASY_MAX_X * EASY_MAX_Y;
;
	ldx     #$00
	lda     #$C0
L0018:	sta     _tempShort0
	stx     _tempShort0+1
;
; gameMode &= ~(0b1 << 6); //clear if flag was ever put down
;
	lda     _gameMode
	and     #$BF
	sta     _gameMode
;
; if(isCustomSeed) rngState.longState = customSeed;
;
	lda     _isCustomSeed
	beq     L0004
	lda     _customSeed+1
	sta     _rngState+1
	lda     _customSeed
	sta     _rngState
;
; boardSeed = rngState.longState;
;
L0004:	lda     _rngState+1
	sta     _boardSeed+1
	lda     _rngState
	sta     _boardSeed
;
; for(global_i = 0; global_i < temp2; global_i++) {
;
	lda     #$00
	sta     _global_i
L0015:	lda     _global_i
	cmp     _temp2
	bcs     L0017
;
; temp3 = 0; //clear the board
;
	lda     #$00
	sta     _temp3
;
; for(global_j = 0; global_j < 8; global_j++) { //8 bits per byte
;
	sta     _global_j
L0016:	lda     _global_j
	cmp     #$08
	bcs     L000A
;
; updateRNGNoController();
;
	jsr     _updateRNGNoController
;
; temp3 = temp3 << 1;
;
	lda     _temp3
	asl     a
	sta     _temp3
;
; if((rngState.longState % tempShort0) < temp0) { //if randomness says to, add a mine
;
	lda     _rngState
	ldx     _rngState+1
	jsr     pushax
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     tosumodax
	cmp     _temp0
	txa
	sbc     #$00
	bcs     L000D
;
; --temp0; //remove 1 flag from the flags counter
;
	dec     _temp0
;
; temp3 |= 0b1; //add a mine to the lsb of the byte
;
	lda     _temp3
	ora     #$01
	sta     _temp3
;
; --tempShort0;
;
L000D:	ldx     _tempShort0
	bne     L000E
	dec     _tempShort0+1
L000E:	dex
	stx     _tempShort0
;
; for(global_j = 0; global_j < 8; global_j++) { //8 bits per byte
;
	inc     _global_j
	jmp     L0016
;
; boardIsMine[global_i] = temp3;
;
L000A:	ldy     _global_i
	lda     _temp3
	sta     _boardIsMine,y
;
; boardIsActivated[global_i] = 0;
;
	ldy     _global_i
	lda     #$00
	sta     _boardIsActivated,y
;
; boardIsFlag[global_i] = 0;
;
	ldy     _global_i
	sta     _boardIsFlag,y
;
; for(global_i = 0; global_i < temp2; global_i++) {
;
	inc     _global_i
	jmp     L0015
;
; gameMode &= ~(0b1 << 4); //clear board is updating
;
L0017:	lda     _gameMode
	and     #$EF
	sta     _gameMode
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ displayBoard (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_displayBoard: near

.segment	"CODE"

;
; pal_bg(gameBgPalette); //set stuff up for the actual game
;
	lda     #<(_gameBgPalette)
	ldx     #>(_gameBgPalette)
	jsr     _pal_bg
;
; pal_spr(sprPalette);
;
	lda     #<(_sprPalette)
	ldx     #>(_sprPalette)
	jsr     _pal_spr
;
; bank_spr(1);
;
	lda     #$01
	jsr     _bank_spr
;
; vram_adr(NTADR_A(0, 0)); //clear the screen
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_fill(BLANK_TILE, 32 * 30);
;
	lda     #$09
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; printTile(0x60, NTADR_A(0, 2)); //draw the flag and the clock
;
	lda     #$60
	jsr     pusha
	ldx     #$20
	lda     #$40
	jsr     _printTile
;
; printTile(0x62, NTADR_A(5, 2));
;
	lda     #$62
	jsr     pusha
	ldx     #$20
	lda     #$45
	jsr     _printTile
;
; if(IS_GAME_HARD()) {
;
	lda     _gameMode
	and     #$08
	beq     L004B
;
; for(global_i = 0; global_i < boardWidth; ++global_i) {
;
	lda     #$00
	sta     _global_i
L0046:	lda     _global_i
	cmp     _boardWidth
	bcs     L0049
;
; for(global_j = 0; global_j < boardHeight; ++global_j) {
;
	lda     #$00
	sta     _global_j
L0047:	lda     _global_j
	cmp     _boardHeight
	bcs     L0048
;
; vram_adr(NTADR_A(global_i, global_j + 4));
;
	ldx     #$00
	lda     _global_j
	clc
	adc     #$04
	bcc     L000B
	inx
L000B:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	lda     _global_i
	ora     ptr1
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0x9 + (((global_i & 0b1) ^ (global_j & 0b1)) << 1)); //alternates as a checkerboard
;
	lda     _global_i
	and     #$01
	jsr     pusha0
	lda     _global_j
	and     #$01
	jsr     tosxora0
	asl     a
	clc
	adc     #$09
	jsr     _vram_put
;
; for(global_j = 0; global_j < boardHeight; ++global_j) {
;
	inc     _global_j
	jmp     L0047
;
; for(global_i = 0; global_i < boardWidth; ++global_i) {
;
L0048:	inc     _global_i
	jmp     L0046
;
; temp2 = 0b00000000; //palette should be 00
;
L0049:	lda     #$00
;
; } else {
;
	jmp     L0042
;
; for(global_i = 0; global_i < boardWidth; ++global_i) {
;
L004B:	sta     _global_i
L004C:	lda     _global_i
	cmp     _boardWidth
	jcs     L004F
;
; for(global_j = 0; global_j < boardHeight; ++global_j) {
;
	lda     #$00
	sta     _global_j
L004D:	lda     _global_j
	cmp     _boardHeight
	jcs     L004E
;
; vram_adr(NTADR_A(global_i << 1, (global_j << 1) + 4));
;
	ldx     #$00
	lda     _global_j
	asl     a
	bcc     L0043
	inx
	clc
L0043:	adc     #$04
	bcc     L0016
	inx
L0016:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _global_i
	asl     a
	bcc     L003E
	inx
L003E:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0xA2/* + temp4*/);
;
	lda     #$A2
	jsr     _vram_put
;
; vram_put(0xA3/* + temp4*/);
;
	lda     #$A3
	jsr     _vram_put
;
; vram_adr(NTADR_A(global_i << 1, (global_j << 1) + 5));
;
	ldx     #$00
	lda     _global_j
	asl     a
	bcc     L0044
	inx
	clc
L0044:	adc     #$05
	bcc     L0017
	inx
L0017:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	sta     ptr1
	ldx     #$00
	lda     _global_i
	asl     a
	bcc     L0040
	inx
L0040:	ora     ptr1
	pha
	txa
	ora     tmp1
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _vram_adr
;
; vram_put(0xB2/* + temp4*/);
;
	lda     #$B2
	jsr     _vram_put
;
; vram_put(0xB3/* + temp4*/);
;
	lda     #$B3
	jsr     _vram_put
;
; for(global_j = 0; global_j < boardHeight; ++global_j) {
;
	inc     _global_j
	jmp     L004D
;
; for(global_i = 0; global_i < boardWidth; ++global_i) {
;
L004E:	inc     _global_i
	jmp     L004C
;
; temp2 = 0b01010101; //palette should be 01 by default
;
L004F:	lda     #$55
L0042:	sta     _temp2
;
; vram_adr(0x23C0);
;
	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; for(global_i = 0; global_i < 8; ++global_i) {
;
	lda     #$00
	sta     _global_i
L0050:	lda     _global_i
	cmp     #$08
	bcs     L0019
;
; for(global_j = 0; global_j < 8; ++global_j) {
;
	lda     #$00
	sta     _global_j
L0051:	lda     _global_j
	cmp     #$08
	bcs     L0052
;
; vram_put(temp2);
;
	lda     _temp2
	jsr     _vram_put
;
; attributeTableMirror[(global_j << 3) + global_i] = temp2;
;
	ldx     #$00
	lda     _global_j
	jsr     aslax3
	clc
	adc     _global_i
	bcc     L0045
	inx
	clc
L0045:	adc     #<(_attributeTableMirror)
	sta     ptr1
	txa
	adc     #>(_attributeTableMirror)
	sta     ptr1+1
	lda     _temp2
	ldy     #$00
	sta     (ptr1),y
;
; for(global_j = 0; global_j < 8; ++global_j) {
;
	inc     _global_j
	jmp     L0051
;
; for(global_i = 0; global_i < 8; ++global_i) {
;
L0052:	inc     _global_i
	jmp     L0050
;
; vram_adr(0x23C0); //make the flag in the top left blue, and the clock black
;
L0019:	ldx     #$23
	lda     #$C0
	jsr     _vram_adr
;
; vram_put(0b00100010);
;
	lda     #$22
	jsr     _vram_put
;
; vram_put(0b00000000);
;
	lda     #$00
	jsr     _vram_put
;
; vram_put(0b00000000);
;
	lda     #$00
	jsr     _vram_put
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; if(numMines == 0) goto finished; //AAAUGH HE USED GOTO ARREST HIM
;
	lda     _numMines
	jeq     L005F
;
; for(cursorX = 0; cursorX < boardWidth; ++cursorX) {
;
	lda     #$00
	sta     _cursorX
L0053:	lda     _cursorX
	cmp     _boardWidth
	bcs     L0057
;
; for(cursorY = 0; cursorY < boardHeight; ++cursorY) {
;
	lda     #$00
	sta     _cursorY
L0054:	lda     _cursorY
	cmp     _boardHeight
	bcs     L0056
;
; if(getTileIsMine()) continue;
;
	jsr     _getTileIsMine
	tax
	bne     L0055
;
; pushCursorXY();
;
	jsr     _pushCursorXY
;
; countMinesAroundTile();
;
	jsr     _countMinesAroundTile
;
; popCursorXY();
;
	jsr     _popCursorXY
;
; if(temp2 == 0) {
;
	lda     _temp2
	bne     L0055
;
; tempTileX = cursorX;
;
	lda     _cursorX
	sta     _tempTileX
;
; tempTileY = cursorY;
;
	lda     _cursorY
	sta     _tempTileY
;
; floodFillZeros();
;
	jsr     _floodFillZeros
;
; goto finished;
;
	jmp     L005E
;
; for(cursorY = 0; cursorY < boardHeight; ++cursorY) {
;
L0055:	inc     _cursorY
	jmp     L0054
;
; for(cursorX = 0; cursorX < boardWidth; ++cursorX) {
;
L0056:	inc     _cursorX
	jmp     L0053
;
; if(IS_GAME_HARD()) {
;
L0057:	lda     _gameMode
	and     #$08
	beq     L0058
;
; if((HARD_MAX_X * HARD_MAX_Y) - numMines <= 1) goto finished;
;
	lda     #$20
	sec
	sbc     _numMines
	pha
	lda     #$03
	sbc     #$00
	tax
	pla
	cmp     #$02
	txa
	sbc     #$00
	bvc     L002E
	eor     #$80
L002E:	asl     a
	lda     #$00
	bcc     L005A
	jmp     L005F
;
; } else if((EASY_MAX_X * EASY_MAX_Y) - numMines <= 1) goto finished;
;
L0058:	lda     #$C0
	sec
	sbc     _numMines
	ldx     #$00
	bcs     L0041
	dex
L0041:	cmp     #$02
	txa
	sbc     #$00
	bvc     L0031
	eor     #$80
L0031:	asl     a
	lda     #$00
	bcs     L005F
;
; for(cursorX = 0; cursorX < boardWidth; ++cursorX) {
;
L005A:	sta     _cursorX
L005B:	lda     _cursorX
	cmp     _boardWidth
	bcs     L005E
;
; for(cursorY = 0; cursorY < boardHeight; ++cursorY) {
;
	lda     #$00
	sta     _cursorY
L005C:	lda     _cursorY
	cmp     _boardHeight
	bcs     L005D
;
; if(!getTileIsMine()) {
;
	jsr     _getTileIsMine
	tax
	bne     L0038
;
; activateTile();
;
	jsr     _activateTile
;
; goto finished;
;
	jmp     L005E
;
; for(cursorY = 0; cursorY < boardHeight; ++cursorY) {
;
L0038:	inc     _cursorY
	jmp     L005C
;
; for(cursorX = 0; cursorX < boardWidth; ++cursorX) {
;
L005D:	inc     _cursorX
	jmp     L005B
;
; cursorX = 0;
;
L005E:	lda     #$00
L005F:	sta     _cursorX
;
; cursorY = 0;
;
	sta     _cursorY
;
; if(temp0 >= (MAX_SCREEN_UPDATES_PER_FRAME - 18)) {
;
	lda     _temp0
	cmp     #$0E
	bcc     L003B
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; temp0 = 0;
;
	lda     #$00
	sta     _temp0
;
; printNumber(numFlags, 2, 3);
;
L003B:	jsr     decsp2
	lda     _numFlags
	ldy     #$01
	sta     (sp),y
	lda     #$02
	dey
	sta     (sp),y
	lda     #$03
	jsr     _printNumber
;
; printTime(7, 3);
;
	lda     #$07
	jsr     pusha
	lda     #$03
	jmp     _printTime

.segment	"RODATA"

M0001:
	.word	$0000
M0002:
	.word	$0000
M0003:
	.word	$0000
M0004:
	.word	$0000
M0005:
	.word	$0000

.endproc

; ---------------------------------------------------------------
; void __near__ setToEasyMode (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setToEasyMode: near

.segment	"CODE"

;
; gameMode &= ~(0b1 << 3);
;
	lda     _gameMode
	and     #$F7
	sta     _gameMode
;
; tileBitShiftOffset = 4;
;
	lda     #$04
	sta     _tileBitShiftOffset
;
; boardWidth = EASY_MAX_X;
;
	lda     #$10
	sta     _boardWidth
;
; boardHeight = EASY_MAX_Y;
;
	lda     #$0C
	sta     _boardHeight
;
; numMines = EASY_NUM_MINES;
;
	lda     #$32
	sta     _numMines
;
; maxMines = EASY_MAX_MINES;
;
	lda     #$96
	sta     _maxMines
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ setToHardMode (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_setToHardMode: near

.segment	"CODE"

;
; gameMode |= (0b1 << 3);
;
	lda     _gameMode
	ora     #$08
	sta     _gameMode
;
; tileBitShiftOffset = 5;
;
	lda     #$05
	sta     _tileBitShiftOffset
;
; boardWidth = HARD_MAX_X;
;
	lda     #$20
	sta     _boardWidth
;
; boardHeight = HARD_MAX_Y;
;
	lda     #$19
	sta     _boardHeight
;
; numMines = HARD_NUM_MINES;
;
	lda     #$AA
	sta     _numMines
;
; maxMines = HARD_MAX_MINES;
;
	lda     #$E1
	sta     _maxMines
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ initState (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_initState: near

.segment	"CODE"

;
; prevController = 0;
;
	lda     #$00
	sta     _prevController
;
; controller = 0;
;
	sta     _controller
;
; gameMode = 0b00000000; //on title screen by default, no other modifiers
;
	sta     _gameMode
;
; rngState.byte1 = 0xB1;
;
	lda     #$B1
	sta     _rngState
;
; rngState.byte2 = 0x68;
;
	lda     #$68
	sta     _rngState+1
;
; frameCount = 0;
;
	lda     #$00
	sta     _frameCount
;
; selectionSprite.hardSelectionSprite.tile = 0x00;
;
	sta     _selectionSprite+1
;
; selectionSprite.hardSelectionSprite.attributes = 0b00000000;
;
	sta     _selectionSprite+2
;
; selectionArrow.tile = 0x02;
;
	lda     #$02
	sta     _selectionArrow+1
;
; selectionArrow.attributes = 0b000000000;
;
	lda     #$00
	sta     _selectionArrow+2
;
; setToEasyMode();
;
	jsr     _setToEasyMode
;
; isCustomSeed = FALSE;
;
	lda     #$00
	sta     _isCustomSeed
;
; customSeed = 0;
;
	sta     _customSeed
	sta     _customSeed+1
;
; isNumberArrowUp = TRUE;
;
	lda     #$01
	sta     _isNumberArrowUp
;
; pal_spr(sprPalette);
;
	lda     #<(_sprPalette)
	ldx     #>(_sprPalette)
	jsr     _pal_spr
;
; bank_spr(1);
;
	lda     #$01
	jmp     _bank_spr

.endproc

; ---------------------------------------------------------------
; void __near__ newGame (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_newGame: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; clear_vram_buffer(); //clear any pending updates...
;
	jsr     _clear_vram_buffer
;
; oam_clear(); //and any remaining sprites
;
	jsr     _oam_clear
;
; gameMode &= ~(0b1 << 5); //set game not paused (for if pressed from the pause menu)
;
	lda     _gameMode
	and     #$DF
	sta     _gameMode
;
; gameMode = (gameMode & ~(0b111)) | 0b001; //set the gamemode to playing a game (gamemode 1)
;
	and     #$F8
	ora     #$01
	sta     _gameMode
;
; cursorX = 0;
;
	lda     #$00
	sta     _cursorX
;
; cursorY = 0;
;
	sta     _cursorY
;
; fillStackPos = 0;
;
	sta     _fillStackPos
;
; frameCount = 0;
;
	sta     _frameCount
;
; selectionArrowIndex = 0;
;
	sta     _selectionArrowIndex
;
; secondsFrameCount = 0;
;
	sta     _secondsFrameCount
;
; timePlayedSeconds = 0;
;
	sta     _timePlayedSeconds
;
; timePlayedMinutes = 0;
;
	sta     _timePlayedMinutes
;
; generateBoard();
;
	jsr     _generateBoard
;
; displayBoard();
;
	jmp     _displayBoard

.endproc

; ---------------------------------------------------------------
; void __near__ updateSelectionArrow (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateSelectionArrow: near

.segment	"CODE"

;
; temp4 = selectionArrowShouldUseArrow[selectionArrowIndex]; //the arrow shouldn't be able to be moved left to right when in this mode
;
	lda     _selectionArrowShouldUseArrow
	ldx     _selectionArrowShouldUseArrow+1
	ldy     _selectionArrowIndex
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     _temp4
;
; if(!temp3) {
;
	lda     _temp3
	bne     L003C
;
; if(BUTTON_DOWN(PAD_DOWN) || (BUTTON_DOWN(PAD_RIGHT) && temp4)) {
;
	lda     _controller
	and     #$04
	beq     L002A
	lda     _prevController
	and     #$04
	beq     L0032
L002A:	lda     _controller
	and     #$01
	beq     L0033
	lda     _prevController
	and     #$01
	bne     L0033
	lda     _temp4
	beq     L0033
;
; ++selectionArrowIndex;
;
L0032:	inc     _selectionArrowIndex
;
; if(selectionArrowIndex == selectionArrowNumIndices) selectionArrowIndex = 0;
;
	lda     _selectionArrowIndex
	cmp     _selectionArrowNumIndices
	bne     L003C
	lda     #$00
	sta     _selectionArrowIndex
;
; } else if(BUTTON_DOWN(PAD_UP) || (BUTTON_DOWN(PAD_LEFT) && temp4)) {
;
	jmp     L003D
L0033:	lda     _controller
	and     #$08
	beq     L0034
	lda     _prevController
	and     #$08
	beq     L003B
L0034:	lda     _controller
	and     #$02
	beq     L003D
	lda     _prevController
	and     #$02
	bne     L003C
	lda     _temp4
	beq     L003D
;
; __asm__("ldx %v", selectionArrowIndex);
;
L003B:	ldx     _selectionArrowIndex
;
; __asm__("dex");
;
	dex
;
; __asm__("bpl @dontUnderflow");
;
	bpl     @dontUnderflow
;
; __asm__("lda %v", selectionArrowNumIndices);
;
	ldx     _selectionArrowNumIndices
;
; __asm__("dex");
;
	dex
;
; __asm__("stx %v", selectionArrowIndex);
;
@dontUnderflow:
	stx     _selectionArrowIndex
;
; temp3 = FALSE;
;
L003C:	lda     #$00
L003D:	sta     _temp3
;
; oam_clear();
;
	jsr     _oam_clear
;
; if(selectionArrowShouldUseArrow[selectionArrowIndex]) {
;
	lda     _selectionArrowShouldUseArrow
	ldx     _selectionArrowShouldUseArrow+1
	ldy     _selectionArrowIndex
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	bne     L0042
;
; }
;
	rts
;
; selectionArrowTargetPosX = selectionArrowPositionsX[selectionArrowIndex];
;
L0042:	lda     _selectionArrowPositionsX
	ldx     _selectionArrowPositionsX+1
	ldy     _selectionArrowIndex
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     _selectionArrowTargetPosX
;
; selectionArrowTargetPosY = selectionArrowPositionsY[selectionArrowIndex];
;
	lda     _selectionArrowPositionsY
	ldx     _selectionArrowPositionsY+1
	ldy     _selectionArrowIndex
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sta     _selectionArrowTargetPosY
;
; temp4 = selectionArrowTargetPosY - selectionArrow.yPos;
;
	sec
	sbc     _selectionArrow
	sta     _temp4
;
; ++fillStackPos;
;
	inc     _fillStackPos
;
; fillStackX[fillStackPos] = temp4; //save it
;
	ldy     _fillStackPos
	lda     _temp4
	sta     _fillStackX,y
;
; temp4 >>= 1;
;
	lsr     a
	sta     _temp4
;
; if(temp4 & (0b1 << 6)) { //if negative, bit 6 instead of 7 because temp4 was just bitshifted by 1 (div by 2)
;
	and     #$40
	beq     L003E
;
; --temp4; //make temp4 negative (but treat it as a 7 bit number, kinda weird but whatever)
;
	dec     _temp4
;
; temp4 ^= 0b01111111;
;
	lda     _temp4
	eor     #$7F
	sta     _temp4
;
; selectionArrow.yPos -= temp4;
;
	eor     #$FF
	sec
	adc     _selectionArrow
	sta     _selectionArrow
;
; if(fillStackX[fillStackPos] == 1) --selectionArrow.yPos;
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	cmp     #$01
	bne     L003F
	dec     _selectionArrow
;
; } else {
;
	jmp     L003F
;
; selectionArrow.yPos += temp4;
;
L003E:	lda     _temp4
	clc
	adc     _selectionArrow
	sta     _selectionArrow
;
; if(fillStackX[fillStackPos] == 0b11111111) ++selectionArrow.yPos;
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	cmp     #$FF
	bne     L003F
	inc     _selectionArrow
;
; temp4 = selectionArrowTargetPosX - selectionArrow.xPos;
;
L003F:	lda     _selectionArrowTargetPosX
	sec
	sbc     _selectionArrow+3
	sta     _temp4
;
; fillStackX[fillStackPos] = temp4; //save it
;
	ldy     _fillStackPos
	lda     _temp4
	sta     _fillStackX,y
;
; temp4 >>= 1; //divide by 2 to make a smooth effect
;
	lsr     a
	sta     _temp4
;
; if(temp4 & (0b1 << 6)) { //if negative, bit 6 instead of 7 because temp4 was just bitshifted by 1 (div by 2)
;
	and     #$40
	beq     L0040
;
; --temp4; //make temp4 negative (but treat it as a 7 bit number, kinda weird but whatever)
;
	dec     _temp4
;
; temp4 ^= 0b01111111;
;
	lda     _temp4
	eor     #$7F
	sta     _temp4
;
; selectionArrow.xPos -= temp4;
;
	eor     #$FF
	sec
	adc     _selectionArrow+3
	sta     _selectionArrow+3
;
; if(fillStackX[fillStackPos] == 1) --selectionArrow.xPos;
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	cmp     #$01
	bne     L0041
	dec     _selectionArrow+3
;
; } else {
;
	jmp     L0041
;
; selectionArrow.xPos += temp4;
;
L0040:	lda     _temp4
	clc
	adc     _selectionArrow+3
	sta     _selectionArrow+3
;
; if(fillStackX[fillStackPos] == 0b11111111) ++selectionArrow.xPos;
;
	ldy     _fillStackPos
	lda     _fillStackX,y
	cmp     #$FF
	bne     L0041
	inc     _selectionArrow+3
;
; --fillStackPos;
;
L0041:	dec     _fillStackPos
;
; oam_spr(selectionArrow.xPos, selectionArrow.yPos, selectionArrow.tile, selectionArrow.attributes);
;
	jsr     decsp3
	lda     _selectionArrow+3
	ldy     #$02
	sta     (sp),y
	lda     _selectionArrow
	dey
	sta     (sp),y
	lda     _selectionArrow+1
	dey
	sta     (sp),y
	lda     _selectionArrow+2
	jmp     _oam_spr

.endproc

; ---------------------------------------------------------------
; void __near__ gameUpdatePaused (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_gameUpdatePaused: near

.segment	"CODE"

;
; updateSelectionArrow();
;
	jsr     _updateSelectionArrow
;
; if(BUTTON_DOWN(PAD_START)) {
;
	lda     _controller
	and     #$10
	beq     L000C
	lda     _prevController
	and     #$10
	beq     L000D
L000C:	rts
;
; switch(selectionArrowIndex) {
;
L000D:	lda     _selectionArrowIndex
;
; }
;
	beq     L0008
	cmp     #$01
	beq     L000E
	cmp     #$02
	beq     L000F
	rts
;
; clearScreen(sizeof(pausedText), 12, 1);
;
L0008:	jsr     decsp2
	lda     #$06
	ldy     #$01
	sta     (sp),y
	lda     #$0C
	dey
	sta     (sp),y
	lda     #$01
	jsr     _clearScreen
;
; clearScreen(sizeof(backText), 13, 2);
;
	jsr     decsp2
	lda     #$0C
	ldy     #$01
	sta     (sp),y
	lda     #$0D
	dey
	sta     (sp),y
	lda     #$02
	jsr     _clearScreen
;
; clearScreen(sizeof(newGameText), 13, 3);
;
	jsr     decsp2
	lda     #$08
	ldy     #$01
	sta     (sp),y
	lda     #$0D
	dey
	sta     (sp),y
	lda     #$03
	jsr     _clearScreen
;
; clearScreen(sizeof(leaveText), 27, 2);
;
	jsr     decsp2
	lda     #$04
	ldy     #$01
	sta     (sp),y
	lda     #$1B
	dey
	sta     (sp),y
	lda     #$02
	jsr     _clearScreen
;
; gameMode &= ~(0b1 << 5);
;
	lda     _gameMode
	and     #$DF
	sta     _gameMode
;
; break;
;
	rts
;
; isCustomSeed = FALSE;
;
L000E:	lda     #$00
	sta     _isCustomSeed
;
; oam_clear();
;
	jsr     _oam_clear
;
; newGame();
;
	jmp     _newGame
;
; gameMode &= ~(0b111); //set the gamemode to title screen (mode 0)
;
L000F:	lda     _gameMode
	and     #$F8
	sta     _gameMode
;
; oam_clear();
;
	jsr     _oam_clear
;
; showTitleScreen();
;
	jmp     _showTitleScreen

.endproc

; ---------------------------------------------------------------
; void __near__ showSelectScreen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_showSelectScreen: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_fill(BLANK_TILE, 32 * 30);
;
	lda     #$09
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; vram_adr(NAMETABLE_A);
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_unrle(selectScreenNametable);
;
	lda     #<(_selectScreenNametable)
	ldx     #>(_selectScreenNametable)
	jsr     _vram_unrle
;
; pal_bg(titleScreenBgPalette);
;
	lda     #<(_titleScreenBgPalette)
	ldx     #>(_titleScreenBgPalette)
	jsr     _pal_bg
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; printNumber(numMines, 6, 12);
;
	jsr     decsp2
	lda     _numMines
	ldy     #$01
	sta     (sp),y
	lda     #$06
	dey
	sta     (sp),y
	lda     #$0C
	jmp     _printNumber

.endproc

; ---------------------------------------------------------------
; void __near__ loadSelectScreen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_loadSelectScreen: near

.segment	"CODE"

;
; gameMode &= ~(0b111);
;
	lda     _gameMode
	and     #$F8
	sta     _gameMode
;
; gameMode |= 0b010; //set the gamemode to choose type of game
;
	ora     #$02
	sta     _gameMode
;
; selectionArrowIndex = 0;
;
	lda     #$00
	sta     _selectionArrowIndex
;
; selectionArrowNumIndices = sizeof(gameSelectPositionsX);
;
	lda     #$06
	sta     _selectionArrowNumIndices
;
; selectionArrowPositionsX = gameSelectPositionsX;
;
	lda     #>(_gameSelectPositionsX)
	sta     _selectionArrowPositionsX+1
	lda     #<(_gameSelectPositionsX)
	sta     _selectionArrowPositionsX
;
; selectionArrowPositionsY = gameSelectPositionsY;
;
	lda     #>(_gameSelectPositionsY)
	sta     _selectionArrowPositionsY+1
	lda     #<(_gameSelectPositionsY)
	sta     _selectionArrowPositionsY
;
; selectionArrowShouldUseArrow = gameSelectShouldUseArrow;
;
	lda     #>(_gameSelectShouldUseArrow)
	sta     _selectionArrowShouldUseArrow+1
	lda     #<(_gameSelectShouldUseArrow)
	sta     _selectionArrowShouldUseArrow
;
; selectionArrow.xPos = gameSelectPositionsX[0];
;
	lda     _gameSelectPositionsX
	sta     _selectionArrow+3
;
; selectionArrow.yPos = gameSelectPositionsY[0];
;
	lda     _gameSelectPositionsY
	sta     _selectionArrow
;
; setToEasyMode();
;
	jsr     _setToEasyMode
;
; showSelectScreen();
;
	jmp     _showSelectScreen

.endproc

; ---------------------------------------------------------------
; void __near__ updateTitleScreen (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateTitleScreen: near

.segment	"CODE"

;
; if((frameCount & 0b11111) == 0) {
;
	lda     _frameCount
	and     #$1F
	bne     L000B
;
; if((frameCount & 0b111111) == 0) printString(pressStartText, sizeof(pressStartText), 10, 17);
;
	lda     _frameCount
	and     #$3F
	bne     L0004
	jsr     decsp4
	lda     #<(_pressStartText)
	ldy     #$02
	sta     (sp),y
	iny
	lda     #>(_pressStartText)
	sta     (sp),y
	lda     #$0B
	ldy     #$01
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #$11
	jsr     _printString
;
; else clearScreen(sizeof(pressStartText), 10, 17);
;
	jmp     L000B
L0004:	jsr     decsp2
	lda     #$0B
	ldy     #$01
	sta     (sp),y
	lda     #$0A
	dey
	sta     (sp),y
	lda     #$11
	jsr     _clearScreen
;
; if(BUTTON_DOWN(PAD_START)) {
;
L000B:	lda     _controller
	and     #$10
	beq     L000D
	lda     _prevController
	and     #$10
	beq     L000E
L000D:	rts
;
; loadSelectScreen();
;
L000E:	jmp     _loadSelectScreen

.endproc

; ---------------------------------------------------------------
; void __near__ updateGameSelection (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_updateGameSelection: near

.segment	"CODE"

;
; printNumber(numMines, 6, 12);
;
	jsr     decsp2
	lda     _numMines
	ldy     #$01
	sta     (sp),y
	lda     #$06
	dey
	sta     (sp),y
	lda     #$0C
	jsr     _printNumber
;
; if(isCustomSeed) printHexNumber(customSeed, 14, 16);
;
	lda     _isCustomSeed
	beq     L0002
	jsr     decsp3
	lda     _customSeed
	ldy     #$01
	sta     (sp),y
	iny
	lda     _customSeed+1
	sta     (sp),y
	lda     #$0E
	ldy     #$00
	sta     (sp),y
	lda     #$10
	jsr     _printHexNumber
;
; else clearScreenPrecalculated(4, NTADR_A(14, 16));
;
	jmp     L0003
L0002:	lda     #$04
	jsr     pusha
	ldx     #$22
	lda     #$0E
	jsr     _clearScreenPrecalculated
;
; clearScreenPrecalculated(4, NTADR_A(14, 17));
;
L0003:	lda     #$04
	jsr     pusha
	ldx     #$22
	lda     #$2E
	jsr     _clearScreenPrecalculated
;
; if(selectionArrowIndex == 2) {
;
	lda     _selectionArrowIndex
	cmp     #$02
	jne     L007C
;
; gameSelectShouldUseArrow[3] = TRUE;
;
	lda     #$01
	sta     _gameSelectShouldUseArrow+3
;
; if(BUTTON_DOWN(PAD_RIGHT)) {
;
	lda     _controller
	and     #$01
	beq     L0068
	lda     _prevController
	and     #$01
	bne     L0068
;
; if(isNumberArrowUp) isNumberArrowUp = FALSE;
;
	lda     _isNumberArrowUp
	beq     L0067
	lda     #$00
	sta     _isNumberArrowUp
;
; else {
;
	jmp     L006D
;
; ++selectionArrowIndex;
;
L0067:	inc     _selectionArrowIndex
;
; temp3 = TRUE;
;
	lda     #$01
	sta     _temp3
;
; goto skipNA;
;
	jmp     L009A
;
; } else if(BUTTON_DOWN(PAD_LEFT)) {
;
L0068:	lda     _controller
	and     #$02
	beq     L006D
	lda     _prevController
	and     #$02
	bne     L006D
;
; if(!isNumberArrowUp) isNumberArrowUp = TRUE;
;
	lda     _isNumberArrowUp
	bne     L006C
	lda     #$01
	sta     _isNumberArrowUp
;
; else {
;
	jmp     L006D
;
; --selectionArrowIndex;
;
L006C:	dec     _selectionArrowIndex
;
; temp3 = TRUE;
;
	lda     #$01
	sta     _temp3
;
; goto skipNA;
;
	jmp     L009A
;
; temp0 = BUTTON_DOWN(PAD_A);
;
L006D:	lda     _controller
	and     #$80
	beq     L0071
	lda     _prevController
	and     #$80
	beq     L0070
	lda     #$00
	jmp     L0071
L0070:	lda     #$01
L0071:	sta     _temp0
;
; temp1 = BUTTON_DOWN(PAD_B);
;
	lda     _controller
	and     #$40
	beq     L0075
	lda     _prevController
	and     #$40
	beq     L0074
	lda     #$00
	jmp     L0075
L0074:	lda     #$01
L0075:	sta     _temp1
;
; if(isNumberArrowUp) {
;
	lda     _isNumberArrowUp
	beq     L0078
;
; one_vram_buffer(0x1E, NTADR_A(3, 12));
;
	lda     #$1E
	jsr     pusha
	ldx     #$21
	lda     #$83
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x0F, NTADR_A(4, 12));
;
	lda     #$0F
	jsr     pusha
	ldx     #$21
	lda     #$84
	jsr     _one_vram_buffer
;
; if(temp0 && numMines <= (minMines - 1)) ++numMines;
;
	lda     _temp0
	beq     L001A
	lda     _numMines
	jsr     pusha0
	lda     _minMines
	sec
	sbc     #$01
	bcs     L001C
	ldx     #$FF
L001C:	jsr     tosicmp
	bmi     L001D
	bne     L001A
L001D:	inc     _numMines
;
; if(temp1 && numMines <= (minMines - 10)) numMines += 10;
;
L001A:	lda     _temp1
	jeq     L009A
	lda     _numMines
	jsr     pusha0
	lda     _minMines
	sec
	sbc     #$0A
	bcs     L0021
	ldx     #$FF
L0021:	jsr     tosicmp
	bmi     L0022
	jne     L009A
L0022:	lda     #$0A
	clc
	adc     _numMines
	sta     _numMines
;
; } else {
;
	jmp     L009A
;
; one_vram_buffer(0x0E, NTADR_A(3, 12));
;
L0078:	lda     #$0E
	jsr     pusha
	ldx     #$21
	lda     #$83
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x1F, NTADR_A(4, 12));
;
	lda     #$1F
	jsr     pusha
	ldx     #$21
	lda     #$84
	jsr     _one_vram_buffer
;
; if(temp0 && numMines >= minMines) --numMines;
;
	lda     _temp0
	beq     L0025
	lda     _numMines
	cmp     _minMines
	bcc     L0025
	dec     _numMines
;
; if(temp1 && numMines >= minMines + 10) numMines -= 10;
;
L0025:	lda     _temp1
	jeq     L009A
	lda     _numMines
	jsr     pusha0
	lda     _minMines
	clc
	adc     #$0A
	bcc     L002B
	ldx     #$01
L002B:	jsr     tosicmp
	jmi     L009A
	lda     _numMines
	sec
	sbc     #$0A
	sta     _numMines
;
; } else if(gameSelectShouldUseArrow[3] == FALSE) {
;
	jmp     L009A
L007C:	lda     _gameSelectShouldUseArrow+3
	jne     L008D
;
; one_vram_buffer(0x0E, NTADR_A(3, 12));
;
	lda     #$0E
	jsr     pusha
	ldx     #$21
	lda     #$83
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x0F, NTADR_A(4, 12));
;
	lda     #$0F
	jsr     pusha
	ldx     #$21
	lda     #$84
	jsr     _one_vram_buffer
;
; if(BUTTON_DOWN(PAD_RIGHT)) {
;
	lda     _controller
	and     #$01
	beq     L0080
	lda     _prevController
	and     #$01
	bne     L0080
;
; isNumberArrowUp = TRUE;
;
	lda     #$01
	sta     _isNumberArrowUp
;
; ++temp1;
;
	inc     _temp1
;
; if(temp1 == 4) {
;
	lda     _temp1
	cmp     #$04
	bne     L0084
;
; gameSelectShouldUseArrow[3] = TRUE;
;
	lda     #$01
	sta     _gameSelectShouldUseArrow+3
;
; ++selectionArrowIndex;
;
	inc     _selectionArrowIndex
;
; temp3 = TRUE;
;
	sta     _temp3
;
; goto skipNA;
;
	jmp     L009A
;
; } else if(BUTTON_DOWN(PAD_LEFT)) {
;
L0080:	lda     _controller
	and     #$02
	beq     L0084
	lda     _prevController
	and     #$02
	bne     L0084
;
; isNumberArrowUp = FALSE;
;
	sta     _isNumberArrowUp
;
; --temp1;
;
	dec     _temp1
;
; if(temp1 == 255) {
;
	lda     _temp1
	cmp     #$FF
	bne     L0084
;
; gameSelectShouldUseArrow[3] = TRUE;
;
	lda     #$01
	sta     _gameSelectShouldUseArrow+3
;
; --selectionArrowIndex;
;
	dec     _selectionArrowIndex
;
; temp3 = TRUE;
;
	sta     _temp3
;
; goto skipNA;
;
	jmp     L009A
;
; one_vram_buffer(UNDERSCORE, NTADR_A(14 + temp1, 17));
;
L0084:	lda     #$5F
	jsr     pusha
	ldx     #$00
	lda     _temp1
	clc
	adc     #$0E
	bcc     L003B
	inx
L003B:	ora     #$20
	pha
	txa
	ora     #$02
	tax
	pla
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _one_vram_buffer
;
; if(BUTTON_DOWN(PAD_A) || BUTTON_DOWN(PAD_START)) {
;
	lda     _controller
	and     #$80
	beq     L0085
	lda     _prevController
	and     #$80
	beq     L0088
L0085:	lda     _controller
	and     #$10
	beq     L0089
	lda     _prevController
	and     #$10
	bne     L0089
;
; tempShort0 = (customSeed >> ((3 - temp1) << 2));
;
L0088:	lda     #$03
	sec
	sbc     _temp1
	asl     a
	asl     a
	tay
	lda     _customSeed
	ldx     _customSeed+1
	jsr     shraxy
	sta     _tempShort0
	stx     _tempShort0+1
;
; ++tempShort0;
;
	inc     _tempShort0
	bne     L0041
	inc     _tempShort0+1
;
; tempShort0 &= 0b1111;
;
L0041:	lda     _tempShort0
	ldx     #$00
	and     #$0F
	sta     _tempShort0
	stx     _tempShort0+1
;
; customSeed &= ~(0b1111 << ((3 - temp1) << 2));
;
	lda     #$03
	sec
	sbc     _temp1
	asl     a
	asl     a
	tay
	lda     #$0F
	jsr     aslaxy
	jsr     complax
	and     _customSeed
	pha
	txa
	and     _customSeed+1
	tax
	pla
	sta     _customSeed
	stx     _customSeed+1
;
; customSeed |= (tempShort0 << ((3 - temp1) << 2));
;
	sta     ptr1
	stx     ptr1+1
	lda     #$03
	sec
	sbc     _temp1
	asl     a
	asl     a
	tay
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     shlaxy
	ora     ptr1
	sta     _customSeed
	txa
	ora     ptr1+1
	sta     _customSeed+1
;
; } else if(BUTTON_DOWN(PAD_B)) {
;
	jmp     L009A
L0089:	lda     _controller
	and     #$40
	jeq     L009A
	lda     _prevController
	and     #$40
	jne     L009A
;
; tempShort0 = (customSeed >> ((3 - temp1) << 2));
;
	lda     #$03
	sec
	sbc     _temp1
	asl     a
	asl     a
	tay
	lda     _customSeed
	ldx     _customSeed+1
	jsr     shraxy
	sta     _tempShort0
	stx     _tempShort0+1
;
; --tempShort0;
;
	ldx     _tempShort0
	bne     L0047
	dec     _tempShort0+1
L0047:	dex
	stx     _tempShort0
;
; tempShort0 &= 0b1111;
;
	lda     _tempShort0
	ldx     #$00
	and     #$0F
	sta     _tempShort0
	stx     _tempShort0+1
;
; customSeed &= ~(0b1111 << ((3 - temp1) << 2));
;
	lda     #$03
	sec
	sbc     _temp1
	asl     a
	asl     a
	tay
	lda     #$0F
	jsr     aslaxy
	jsr     complax
	and     _customSeed
	pha
	txa
	and     _customSeed+1
	tax
	pla
	sta     _customSeed
	stx     _customSeed+1
;
; customSeed |= (tempShort0 << ((3 - temp1) << 2));
;
	sta     ptr1
	stx     ptr1+1
	lda     #$03
	sec
	sbc     _temp1
	asl     a
	asl     a
	tay
	lda     _tempShort0
	ldx     _tempShort0+1
	jsr     shlaxy
	ora     ptr1
	sta     _customSeed
	txa
	ora     ptr1+1
	sta     _customSeed+1
;
; } else {
;
	jmp     L009A
;
; one_vram_buffer(0x0E, NTADR_A(3, 12));
;
L008D:	lda     #$0E
	jsr     pusha
	ldx     #$21
	lda     #$83
	jsr     _one_vram_buffer
;
; one_vram_buffer(0x0F, NTADR_A(4, 12));
;
	lda     #$0F
	jsr     pusha
	ldx     #$21
	lda     #$84
	jsr     _one_vram_buffer
;
; if(BUTTON_DOWN(PAD_RIGHT) || BUTTON_DOWN(PAD_DOWN)) isNumberArrowUp = TRUE;
;
	lda     _controller
	and     #$01
	beq     L008E
	lda     _prevController
	and     #$01
	beq     L0091
L008E:	lda     _controller
	and     #$04
	beq     L0063
	lda     _prevController
	and     #$04
	beq     L0091
	lda     #$00
	jmp     L0063
L0091:	lda     #$01
;
; else isNumberArrowUp = FALSE;
;
L0063:	sta     _isNumberArrowUp
;
; gameSelectShouldUseArrow[3] = TRUE;
;
	lda     #$01
	sta     _gameSelectShouldUseArrow+3
;
; if(BUTTON_DOWN(PAD_A) || BUTTON_DOWN(PAD_START)) {
;
	lda     _controller
	and     #$80
	beq     L0093
	lda     _prevController
	and     #$80
	beq     L0096
L0093:	lda     _controller
	and     #$10
	jeq     L009A
	lda     _prevController
	and     #$10
	jne     L009A
;
; switch(selectionArrowIndex) {
;
L0096:	lda     _selectionArrowIndex
;
; }
;
	beq     L0056
	cmp     #$01
	beq     L0057
	cmp     #$03
	beq     L0097
	cmp     #$04
	jeq     L0098
	cmp     #$05
	jeq     L005A
	jmp     L009A
;
; setToEasyMode();
;
L0056:	jsr     _setToEasyMode
;
; one_vram_buffer(OPENING_BRACKET, NTADR_A(3, 8));
;
	lda     #$5D
	jsr     pusha
	ldx     #$21
	lda     #$03
	jsr     _one_vram_buffer
;
; one_vram_buffer(CLOSING_BRACKET, NTADR_A(8, 8));
;
	lda     #$5E
	jsr     pusha
	ldx     #$21
	lda     #$08
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(10, 8));
;
	lda     #$09
	jsr     pusha
	ldx     #$21
	lda     #$0A
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(15, 8));
;
	lda     #$09
	jsr     pusha
	ldx     #$21
	lda     #$0F
	jsr     _one_vram_buffer
;
; break;
;
	jmp     L009A
;
; setToHardMode();
;
L0057:	jsr     _setToHardMode
;
; one_vram_buffer(OPENING_BRACKET, NTADR_A(10, 8));
;
	lda     #$5D
	jsr     pusha
	ldx     #$21
	lda     #$0A
	jsr     _one_vram_buffer
;
; one_vram_buffer(CLOSING_BRACKET, NTADR_A(15, 8));
;
	lda     #$5E
	jsr     pusha
	ldx     #$21
	lda     #$0F
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(3, 8));
;
	lda     #$09
	jsr     pusha
	ldx     #$21
	lda     #$03
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(8, 8));
;
	lda     #$09
	jsr     pusha
	ldx     #$21
	lda     #$08
	jsr     _one_vram_buffer
;
; break;
;
	jmp     L009A
;
; gameSelectShouldUseArrow[3] = FALSE;
;
L0097:	lda     #$00
	sta     _gameSelectShouldUseArrow+3
;
; temp1 = 0;
;
	sta     _temp1
;
; isCustomSeed = TRUE;
;
	lda     #$01
	sta     _isCustomSeed
;
; one_vram_buffer(OPENING_BRACKET, NTADR_A(3, 16));
;
	lda     #$5D
	jsr     pusha
	ldx     #$22
	lda     #$03
	jsr     _one_vram_buffer
;
; one_vram_buffer(CLOSING_BRACKET, NTADR_A(7, 16));
;
	lda     #$5E
	jsr     pusha
	ldx     #$22
	lda     #$07
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(9, 16));
;
	lda     #$09
	jsr     pusha
	ldx     #$22
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(12, 16));
;
	lda     #$09
	jsr     pusha
	ldx     #$22
	lda     #$0C
	jsr     _one_vram_buffer
;
; break;
;
	jmp     L009A
;
; isCustomSeed = FALSE;
;
L0098:	lda     #$00
	sta     _isCustomSeed
;
; one_vram_buffer(OPENING_BRACKET, NTADR_A(9, 16));
;
	lda     #$5D
	jsr     pusha
	ldx     #$22
	lda     #$09
	jsr     _one_vram_buffer
;
; one_vram_buffer(CLOSING_BRACKET, NTADR_A(12, 16));
;
	lda     #$5E
	jsr     pusha
	ldx     #$22
	lda     #$0C
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(3, 16));
;
	lda     #$09
	jsr     pusha
	ldx     #$22
	lda     #$03
	jsr     _one_vram_buffer
;
; one_vram_buffer(BLANK_TILE, NTADR_A(7, 16));
;
	lda     #$09
	jsr     pusha
	ldx     #$22
	lda     #$07
	jsr     _one_vram_buffer
;
; break;
;
	jmp     L009A
;
; if(customSeed == 0) isCustomSeed = FALSE;
;
L005A:	lda     _customSeed
	ora     _customSeed+1
	bne     L0099
	sta     _isCustomSeed
;
; frameCount = 0;
;
L0099:	lda     #$00
	sta     _frameCount
;
; newGame();
;
	jmp     _newGame
;
; if(BUTTON_DOWN(PAD_SELECT)) goto startGame;
;
L009A:	lda     _controller
	and     #$20
	beq     L005F
	lda     _prevController
	and     #$20
	beq     L005A
;
; updateSelectionArrow(); //done last because otherwise it messed with the number arrow
;
L005F:	jmp     _updateSelectionArrow

.segment	"RODATA"

M0001:
	.word	$0000
M0002:
	.word	$0000
M0003:
	.word	$0000
M0004:
	.word	$0000

.endproc

; ---------------------------------------------------------------
; void __near__ update (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_update: near

.segment	"CODE"

;
; updateController();
;
	jsr     _updateController
;
; updateRNG();
;
	jsr     _updateRNG
;
; switch(gameMode & 0b111) {
;
	lda     _gameMode
	and     #$07
;
; }
;
	beq     L000B
	cmp     #$01
	beq     L000D
	cmp     #$02
	beq     L0009
	cmp     #$03
	beq     L000E
	jmp     L000B
;
; if(IS_GAME_PAUSED()) {
;
L000D:	lda     _gameMode
	and     #$20
	beq     L0005
;
; gameUpdatePaused();
;
	jsr     _gameUpdatePaused
;
; } else {
;
	jmp     L000E
;
; gameUpdateDifficultyIndependent();
;
L0005:	jsr     _gameUpdateDifficultyIndependent
;
; if(IS_GAME_HARD()) gameUpdateHard();
;
	lda     _gameMode
	and     #$08
	beq     L0007
	jsr     _gameUpdateHard
;
; else gameUpdateEasy();
;
	jmp     L000E
L0007:	jsr     _gameUpdateEasy
;
; break;
;
	jmp     L000E
;
; updateGameSelection();
;
L0009:	jsr     _updateGameSelection
;
; break;
;
	jmp     L000E
;
; updateTitleScreen();
;
L000B:	jsr     _updateTitleScreen
;
; ++frameCount;
;
L000E:	inc     _frameCount
;
; }
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; ppu_off();
;
	jsr     _ppu_off
;
; initState();
;
	jsr     _initState
;
; showTitleScreen();
;
	jsr     _showTitleScreen
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; ppu_wait_nmi();
;
L0002:	jsr     _ppu_wait_nmi
;
; update();
;
	jsr     _update
;
; while(TRUE) {
;
	jmp     L0002

.endproc

